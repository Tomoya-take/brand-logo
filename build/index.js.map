{
  "version": 3,
  "sources": ["<stdin>", "../node_modules/@remix-run/dev/dist/config/defaults/entry.server.node.tsx", "../app/root.tsx", "../app/routes/api.auth.callback.tsx", "../app/shopify.server.ts", "../node_modules/@shopify/src/server/types.ts", "../node_modules/@shopify/src/server/version.ts", "../node_modules/@shopify/src/server/authenticate/webhooks/register.ts", "../node_modules/@shopify/src/server/authenticate/const.ts", "../node_modules/@shopify/src/server/authenticate/helpers/ensure-cors-headers.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect-to-bounce-page.ts", "../node_modules/@shopify/src/server/authenticate/helpers/respond-to-invalid-session-token.ts", "../node_modules/@shopify/src/server/authenticate/helpers/get-shop-from-request.ts", "../node_modules/@shopify/src/server/authenticate/helpers/validate-session-token.ts", "../node_modules/@shopify/src/server/authenticate/helpers/get-session-token-header.ts", "../node_modules/@shopify/src/server/authenticate/helpers/reject-bot-request.ts", "../node_modules/@shopify/src/server/authenticate/helpers/respond-to-options-request.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/begin-auth.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect-with-exitiframe.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect-with-app-bridge-headers.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect-to-auth-page.ts", "../node_modules/@shopify/src/server/authenticate/helpers/invalidate-access-token.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/cancel.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/require.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/helpers.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/request.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/check.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/create-usage-record.ts", "../node_modules/@shopify/src/server/authenticate/admin/billing/update-usage-subscription-capped-amount.ts", "../node_modules/@shopify/src/server/clients/admin/graphql.ts", "../node_modules/@shopify/src/server/clients/admin/rest.ts", "../node_modules/@shopify/src/server/clients/admin/factory.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/create-admin-api-context.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect-to-shopify-or-app-root.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/ensure-app-is-embedded-if-required.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/ensure-session-token-search-param-if-required.ts", "../node_modules/@shopify/src/server/authenticate/helpers/app-bridge-url.ts", "../node_modules/@shopify/src/server/authenticate/helpers/add-response-headers.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/validate-redirect-url.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/render-app-bridge.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/validate-shop-and-host-params.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/redirect-to-install-page.ts", "../node_modules/@shopify/src/server/authenticate/admin/scope/client/fetch-scopes-details.ts", "../node_modules/@shopify/src/server/authenticate/admin/scope/request.ts", "../node_modules/@shopify/src/server/authenticate/admin/scope/query.ts", "../node_modules/@shopify/src/server/authenticate/admin/scope/client/revoke-scopes.ts", "../node_modules/@shopify/src/server/authenticate/admin/scope/revoke.ts", "../node_modules/@shopify/src/server/authenticate/admin/scope/factory.ts", "../node_modules/@shopify/src/server/authenticate/admin/authenticate.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/handle-client-error.ts", "../node_modules/@shopify/src/server/authenticate/helpers/create-or-load-offline-session.ts", "../node_modules/@shopify/src/server/authenticate/webhooks/authenticate.ts", "../node_modules/@shopify/src/server/override-logger.ts", "../node_modules/@shopify/src/server/authenticate/login/login.ts", "../node_modules/@shopify/src/server/errors.ts", "../node_modules/@shopify/src/server/unauthenticated/admin/factory.ts", "../node_modules/@shopify/src/server/authenticate/public/extension/authenticate.ts", "../node_modules/@shopify/src/server/authenticate/public/checkout/authenticate.ts", "../node_modules/@shopify/src/server/clients/storefront/factory.ts", "../node_modules/@shopify/src/server/authenticate/public/appProxy/authenticate.ts", "../node_modules/@shopify/src/server/authenticate/public/customer-account/authenticate.ts", "../node_modules/@shopify/src/server/authenticate/public/pos/authenticate.ts", "../node_modules/@shopify/src/server/authenticate/public/factory.ts", "../node_modules/@shopify/src/server/unauthenticated/storefront/factory.ts", "../node_modules/@shopify/src/server/authenticate/admin/helpers/trigger-after-auth-hook.ts", "../node_modules/@shopify/src/server/authenticate/admin/strategies/auth-code-flow.ts", "../node_modules/@shopify/src/server/authenticate/admin/strategies/token-exchange.ts", "../node_modules/@shopify/src/server/authenticate/admin/strategies/merchant-custom-app.ts", "../node_modules/@shopify/src/server/authenticate/helpers/idempotent-promise-handler.ts", "../node_modules/@shopify/src/server/authenticate/flow/authenticate.ts", "../node_modules/@shopify/src/server/authenticate/fulfillment-service/authenticate.ts", "../node_modules/@shopify/src/server/future/flags.ts", "../node_modules/@shopify/src/server/shopify-app.ts", "../node_modules/@shopify/src/server/index.ts", "../app/routes/api.auth.tsx", "../app/routes/api.test.tsx", "../app/routes/_index.tsx", "../app/utils/authenticatedFetch.js", "server-assets-manifest:@remix-run/dev/assets-manifest", "server-entry-module:@remix-run/dev/server-build"],
  "sourcesContent": ["export * from \"@remix-run/dev/server-build\";", "import { PassThrough } from \"node:stream\";\n\nimport type { AppLoadContext, EntryContext } from \"@remix-run/node\";\nimport { createReadableStreamFromReadable } from \"@remix-run/node\";\nimport { RemixServer } from \"@remix-run/react\";\nimport * as isbotModule from \"isbot\";\nimport { renderToPipeableStream } from \"react-dom/server\";\n\nconst ABORT_DELAY = 5_000;\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext,\n  loadContext: AppLoadContext\n) {\n  let prohibitOutOfOrderStreaming =\n    isBotRequest(request.headers.get(\"user-agent\")) || remixContext.isSpaMode;\n\n  return prohibitOutOfOrderStreaming\n    ? handleBotRequest(\n        request,\n        responseStatusCode,\n        responseHeaders,\n        remixContext\n      )\n    : handleBrowserRequest(\n        request,\n        responseStatusCode,\n        responseHeaders,\n        remixContext\n      );\n}\n\n// We have some Remix apps in the wild already running with isbot@3 so we need\n// to maintain backwards compatibility even though we want new apps to use\n// isbot@4.  That way, we can ship this as a minor Semver update to @remix-run/dev.\nfunction isBotRequest(userAgent: string | null) {\n  if (!userAgent) {\n    return false;\n  }\n\n  // isbot >= 3.8.0, >4\n  if (\"isbot\" in isbotModule && typeof isbotModule.isbot === \"function\") {\n    return isbotModule.isbot(userAgent);\n  }\n\n  // isbot < 3.8.0\n  if (\"default\" in isbotModule && typeof isbotModule.default === \"function\") {\n    return isbotModule.default(userAgent);\n  }\n\n  return false;\n}\n\nfunction handleBotRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  return new Promise((resolve, reject) => {\n    let shellRendered = false;\n    const { pipe, abort } = renderToPipeableStream(\n      <RemixServer\n        context={remixContext}\n        url={request.url}\n        abortDelay={ABORT_DELAY}\n      />,\n      {\n        onAllReady() {\n          shellRendered = true;\n          const body = new PassThrough();\n          const stream = createReadableStreamFromReadable(body);\n\n          responseHeaders.set(\"Content-Type\", \"text/html\");\n\n          resolve(\n            new Response(stream, {\n              headers: responseHeaders,\n              status: responseStatusCode,\n            })\n          );\n\n          pipe(body);\n        },\n        onShellError(error: unknown) {\n          reject(error);\n        },\n        onError(error: unknown) {\n          responseStatusCode = 500;\n          // Log streaming rendering errors from inside the shell.  Don't log\n          // errors encountered during initial shell rendering since they'll\n          // reject and get logged in handleDocumentRequest.\n          if (shellRendered) {\n            console.error(error);\n          }\n        },\n      }\n    );\n\n    setTimeout(abort, ABORT_DELAY);\n  });\n}\n\nfunction handleBrowserRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  return new Promise((resolve, reject) => {\n    let shellRendered = false;\n    const { pipe, abort } = renderToPipeableStream(\n      <RemixServer\n        context={remixContext}\n        url={request.url}\n        abortDelay={ABORT_DELAY}\n      />,\n      {\n        onShellReady() {\n          shellRendered = true;\n          const body = new PassThrough();\n          const stream = createReadableStreamFromReadable(body);\n\n          responseHeaders.set(\"Content-Type\", \"text/html\");\n\n          resolve(\n            new Response(stream, {\n              headers: responseHeaders,\n              status: responseStatusCode,\n            })\n          );\n\n          pipe(body);\n        },\n        onShellError(error: unknown) {\n          reject(error);\n        },\n        onError(error: unknown) {\n          responseStatusCode = 500;\n          // Log streaming rendering errors from inside the shell.  Don't log\n          // errors encountered during initial shell rendering since they'll\n          // reject and get logged in handleDocumentRequest.\n          if (shellRendered) {\n            console.error(error);\n          }\n        },\n      }\n    );\n\n    setTimeout(abort, ABORT_DELAY);\n  });\n}\n", "// app/root.tsx\r\nimport {\r\n  Links,\r\n  LiveReload,\r\n  Meta,\r\n  Outlet,\r\n  Scripts,\r\n  ScrollRestoration,\r\n  useLoaderData,\r\n} from \"@remix-run/react\";\r\nimport type { LinksFunction, MetaFunction, LoaderFunctionArgs } from \"@remix-run/node\";\r\n\r\nexport const meta: MetaFunction = () => {\r\n  return [{ title: \"Brand Logo App\" }];\r\n};\r\n\r\nexport async function loader({ request }: LoaderFunctionArgs) {\r\n  const url = new URL(request.url);\r\n  return {\r\n    SHOPIFY_API_KEY: process.env.SHOPIFY_API_KEY || \"\",\r\n    HOST: url.searchParams.get(\"host\") || \"\",\r\n  };\r\n}\r\n\r\nexport default function App() {\r\n  const data = useLoaderData<typeof loader>();\r\n\r\n  return (\r\n    <html lang=\"en\">\r\n      <head>\r\n        <Meta />\r\n        <Links />\r\n      </head>\r\n      <body>\r\n        <Outlet />\r\n        <ScrollRestoration />\r\n        <Scripts />\r\n        <LiveReload />\r\n\r\n        {/* window \u306B API KEY \u3068 host \u3092\u57CB\u3081\u8FBC\u3080 */}\r\n<script\r\n  dangerouslySetInnerHTML={{\r\n    __html: `\r\n      window.__SHOPIFY_API_KEY__ = \"${data.SHOPIFY_API_KEY}\";\r\n      window.__SHOPIFY_HOST__ = \"${data.HOST}\";\r\n    `,\r\n  }}\r\n/>\r\n\r\n      </body>\r\n    </html>\r\n  );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "import { LoaderFunctionArgs } from \"@remix-run/node\";\r\nimport { shopify } from \"~/shopify.server\";\r\n\r\nexport async function loader({ request }: LoaderFunctionArgs) {\r\n  // \u3053\u308C\u3082 Response \u3092\u8FD4\u3059\uFF08\u8A8D\u8A3C\u6210\u529F\u6642\u306F\u30BB\u30C3\u30B7\u30E7\u30F3\u4FDD\u5B58\u3001\u30EA\u30C0\u30A4\u30EC\u30AF\u30C8\u542B\u3080\uFF09\r\n  return shopify.authenticate.admin(request);\r\n}\r\n\r\n", "import 'dotenv/config';\r\nimport { shopifyApp } from \"@shopify/shopify-app-remix/server\";\r\nimport { SQLiteSessionStorage } from \"@shopify/shopify-app-session-storage-sqlite\";\r\n\r\nconst sessionStorage = new SQLiteSessionStorage(\"./database.sqlite\");\r\n\r\nexport const shopify = shopifyApp({\r\n  apiKey: process.env.SHOPIFY_API_KEY!,\r\n  apiSecretKey: process.env.SHOPIFY_API_SECRET!,\r\n  scopes: process.env.SHOPIFY_SCOPES?.split(\",\") || [],\r\n  appUrl: process.env.SHOPIFY_APP_URL!,\r\n  sessionStorage,\r\n});\r\n\r\nexport const { authenticate } = shopify;\r\n\r\n\r\n", "import {\n  RegisterReturn,\n  Shopify,\n  ShopifyRestResources,\n} from '@shopify/shopify-api';\nimport {SessionStorage} from '@shopify/shopify-app-session-storage';\n\nimport type {AuthenticateAdmin} from './authenticate/admin/types';\nimport type {AuthenticateFlow} from './authenticate/flow/types';\nimport {AuthenticateFulfillmentService} from './authenticate/fulfillment-service/types';\nimport type {AuthenticatePublic} from './authenticate/public/types';\nimport type {\n  AuthenticateWebhook,\n  RegisterWebhooksOptions,\n} from './authenticate/webhooks/types';\nimport type {AppConfig, AppConfigArg} from './config-types';\nimport type {\n  ApiConfigWithFutureFlags,\n  ApiFutureFlags,\n  FutureFlagOptions,\n} from './future/flags';\nimport type {Unauthenticated} from './unauthenticated/types';\n\nexport interface BasicParams<\n  Future extends FutureFlagOptions = FutureFlagOptions,\n> {\n  api: Shopify<\n    ApiConfigWithFutureFlags<Future>,\n    ShopifyRestResources,\n    ApiFutureFlags<Future>\n  >;\n  config: AppConfig;\n  logger: Shopify['logger'];\n}\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Use this enum to replace the isCustomStoreApp config option in shopify-api-js\nexport enum AppDistribution {\n  AppStore = 'app_store',\n  SingleMerchant = 'single_merchant',\n  ShopifyAdmin = 'shopify_admin',\n}\n\ntype RegisterWebhooks = (\n  options: RegisterWebhooksOptions,\n) => Promise<RegisterReturn | void>;\n\nexport enum LoginErrorType {\n  MissingShop = 'MISSING_SHOP',\n  InvalidShop = 'INVALID_SHOP',\n}\n\nexport interface LoginError {\n  shop?: LoginErrorType;\n}\n\ntype Login = (request: Request) => Promise<LoginError | never>;\n\ntype AddDocumentResponseHeaders = (request: Request, headers: Headers) => void;\n\ntype RestResourcesType<Config extends AppConfigArg> =\n  Config['restResources'] extends ShopifyRestResources\n    ? Config['restResources']\n    : ShopifyRestResources;\n\ntype SessionStorageType<Config extends AppConfigArg> =\n  Config['sessionStorage'] extends SessionStorage\n    ? Config['sessionStorage']\n    : SessionStorage;\n\ninterface Authenticate<Config extends AppConfigArg> {\n  /**\n   * Authenticate an admin Request and get back an authenticated admin context.  Use the authenticated admin context to interact with Shopify.\n   *\n   * Examples of when to use this are requests from your app's UI, or requests from admin extensions.\n   *\n   * If there is no session for the Request, this will redirect the merchant to correct auth flows.\n   *\n   * @example\n   * <caption>Authenticating a request for an embedded app.</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {admin, session, sessionToken, billing} = authenticate.admin(request);\n   *   const response = await admin.graphql(`{ shop { name } }`)\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  admin: AuthenticateAdmin<Config, RestResourcesType<Config>>;\n\n  /**\n   * Authenticate a Flow extension Request and get back an authenticated context, containing an admin context to access\n   * the API, and the payload of the request.\n   *\n   * If there is no session for the Request, this will return an HTTP 400 error.\n   *\n   * Note that this will always be a POST request.\n   *\n   * @example\n   * <caption>Authenticating a Flow extension request.</caption>\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { ActionFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const {admin, session, payload} = authenticate.flow(request);\n   *\n   *   // Perform flow extension logic\n   *\n   *   // Return a 200 response\n   *   return null;\n   * }\n   * ```\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const authenticate = shopify.authenticate;\n   * ```\n   */\n  flow: AuthenticateFlow<Config, RestResourcesType<Config>>;\n\n  /**\n   * Authenticate a request from a fulfillment service and get back an authenticated context.\n   *\n   * @example\n   * <caption>Shopify session for the fulfillment service request.</caption>\n   * <description>Use the session associated with this request to use the Admin GraphQL API </description>\n   * ```ts\n   * // /app/routes/fulfillment_order_notification.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const { admin, session } = await authenticate.fulfillmentService(request);\n   *\n   *   console.log(session.id)\n   *\n   *   return new Response();\n   * }\n   * ```\n   * */\n  fulfillmentService: AuthenticateFulfillmentService<\n    Config,\n    RestResourcesType<Config>\n  >;\n\n  /**\n   * Authenticate a public request and get back a session token.\n   *\n   * @example\n   * <caption>Authenticating a request from a checkout extension</caption>\n   *\n   * ```ts\n   * // /app/routes/api/checkout.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticate } from \"../../shopify.server\";\n   * import { getWidgets } from \"~/db/widgets\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {sessionToken} = authenticate.public.checkout(request);\n   *\n   *   return json(await getWidgets(sessionToken));\n   * }\n   * ```\n   */\n  public: AuthenticatePublic<Config>;\n\n  /**\n   * Authenticate a Shopify webhook request, get back an authenticated admin context and details on the webhook request\n   * \n   * @example\n   * <caption>Authenticating a webhook request</caption>\n   *\n   * ```ts\n   * // app/routes/webhooks.ts\n   * import { ActionFunctionArgs } from \"@remix-run/node\";\n   * import { authenticate } from \"../shopify.server\";\n   * import db from \"../db.server\";\n   *\n   * export const action = async ({ request }: ActionFunctionArgs) => {\n   *   const { topic, shop, session, payload } = await authenticate.webhook(request);\n   * \n   *   // Webhook requests can trigger after an app is uninstalled\n   *   // If the app is already uninstalled, the session may be undefined.\n   *   if (!session) {\n   *     throw new Response();\n   *   }\n   * \n   *   // Handle the webhook\n   *   console.log(`${TOPIC} webhook received with payload:`, JSON.stringify(payload))\n   *\n   *   throw new Response();\n   * };\n   * ```\n   * \n   * @example\n   * <caption>Registering app-specific webhooks (Recommended)</caption>\n   * ```toml\n   * # shopify.app.toml\n   * [webhooks]\n   * api_version = \"2024-07\"\n\n   *   [[webhooks.subscriptions]]\n   *   topics = [\"products/create\"]\n   *   uri = \"/webhooks/products/create\"\n   * \n   * ```\n   * \n   * @example\n   * <caption>Registering shop-specific webhooks.</caption>\n   * <description>In many cases you won't need this. Please see: [https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions](https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions)\n   * </description>\n   * ```ts\n   * // app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   webhooks: {\n   *     PRODUCTS_CREATE: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *       callbackUrl: \"/webhooks/products/create\",\n   *     },\n   *   },\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       // Register webhooks for the shop\n   *       // In this example, every shop will have these webhooks\n   *       // You could wrap this in some custom shop specific conditional logic if needed\n   *       shopify.registerWebhooks({ session });\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  webhook: AuthenticateWebhook<Config, RestResourcesType<Config>, string>;\n}\n\nexport interface ShopifyAppBase<Config extends AppConfigArg> {\n  /**\n   * The `SessionStorage` instance you passed in as a config option.\n   *\n   * @example\n   * <caption>Storing sessions with Prisma.</caption>\n   * <description>Import the `@shopify/shopify-app-session-storage-prisma` package to store sessions in your Prisma database.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   * import { PrismaSessionStorage } from \"@shopify/shopify-app-session-storage-prisma\";\n   * import prisma from \"~/db.server\";\n   *\n   * const shopify = shopifyApp({\n   *   sessionStorage: new PrismaSessionStorage(prisma),\n   *   // ...etc\n   * })\n   *\n   * // shopify.sessionStorage is an instance of PrismaSessionStorage\n   * ```\n   */\n  sessionStorage?: SessionStorageType<Config>;\n\n  /**\n   * Adds the required Content Security Policy headers for Shopify apps to the given Headers object.\n   *\n   * {@link https://shopify.dev/docs/apps/store/security/iframe-protection}\n   *\n   * @example\n   * <caption>Return headers on all requests.</caption>\n   * <description>Add headers to all HTML requests by calling `shopify.addDocumentResponseHeaders` in `entry.server.tsx`.</description>\n   *\n   * ```\n   * // ~/shopify.server.ts\n   * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * export const addDocumentResponseheaders = shopify.addDocumentResponseheaders;\n   * ```\n   *\n   * ```ts\n   * // entry.server.tsx\n   * import { addDocumentResponseHeaders } from \"~/shopify.server\";\n   *\n   * export default function handleRequest(\n   *   request: Request,\n   *   responseStatusCode: number,\n   *   responseHeaders: Headers,\n   *   remixContext: EntryContext\n   * ) {\n   *   const markup = renderToString(\n   *     <RemixServer context={remixContext} url={request.url} />\n   *   );\n   *\n   *   responseHeaders.set(\"Content-Type\", \"text/html\");\n   *   addDocumentResponseHeaders(request, responseHeaders);\n   *\n   *   return new Response(\"<!DOCTYPE html>\" + markup, {\n   *     status: responseStatusCode,\n   *     headers: responseHeaders,\n   *   });\n   * }\n   * ```\n   */\n  addDocumentResponseHeaders: AddDocumentResponseHeaders;\n\n  /**\n   * Register shop-specific webhook subscriptions using the Admin GraphQL API.\n   *\n   * In many cases defining app-specific webhooks in the `shopify.app.toml` will be sufficient and easier to manage.  Please see:\n   *\n   * {@link https://shopify.dev/docs/apps/build/webhooks/subscribe#app-specific-vs-shop-specific-subscriptions}\n   *\n   * You should only use this if you need shop-specific webhooks.\n   *\n   * @example\n   * <caption>Registering shop-specific webhooks after install</caption>\n   * <description>Trigger the registration to create the shop-specific webhook subscriptions after a merchant installs your app using the `afterAuth` hook. Learn more about [subscribing to webhooks.](https://shopify.dev/docs/api/shopify-app-remix/v3/guide-webhooks)</description>\n   * ```ts\n   * // app/shopify.server.ts\n   * import { DeliveryMethod, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   webhooks: {\n   *     PRODUCTS_CREATE: {\n   *       deliveryMethod: DeliveryMethod.Http,\n   *       callbackUrl: \"/webhooks/products/create\",\n   *     },\n   *   },\n   *   hooks: {\n   *     afterAuth: async ({ session }) => {\n   *       // Register webhooks for the shop\n   *       // In this example, every shop will have these webhooks\n   *       // You could wrap this in some custom shop specific conditional logic if needed\n   *       shopify.registerWebhooks({ session });\n   *     },\n   *   },\n   *   // ...etc\n   * });\n   * ```\n   */\n  registerWebhooks: RegisterWebhooks;\n\n  /**\n   * Ways to authenticate requests from different surfaces across Shopify.\n   *\n   * @example\n   * <caption>Authenticate Shopify requests.</caption>\n   * <description>Use the functions in `authenticate` to validate requests coming from Shopify.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const {admin, session, sessionToken, billing} = shopify.authenticate.admin(request);\n   *   const response = admin.graphql(`{ shop { name } }`)\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  authenticate: Authenticate<Config>;\n\n  /**\n   * Ways to get Contexts from requests that do not originate from Shopify.\n   *\n   * @example\n   * <caption>Using unauthenticated contexts.</caption>\n   * <description>Create contexts for requests that don't come from Shopify.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/**\\/*.jsx\n   * import { LoaderFunctionArgs, json } from \"@remix-run/node\";\n   * import { authenticateExternal } from \"~/helpers/authenticate\"\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const shop = await authenticateExternal(request)\n   *   const {admin} = await shopify.unauthenticated.admin(shop);\n   *   const response = admin.graphql(`{ shop { currencyCode } }`)\n   *\n   *   return json(await response.json());\n   * }\n   * ```\n   */\n  unauthenticated: Unauthenticated<Config, RestResourcesType<Config>>;\n}\n\nexport interface ShopifyAppLogin {\n  /**\n   * Log a merchant in, and redirect them to the app root. Will redirect the merchant to authentication if a shop is\n   * present in the URL search parameters or form data.\n   *\n   * This function won't be present when the `distribution` config option is set to `AppDistribution.ShopifyAdmin`,\n   * because Admin apps aren't allowed to show a login page.\n   *\n   * @example\n   * <caption>Creating a login page.</caption>\n   * <description>Use `shopify.login` to create a login form, in a route that can handle GET and POST requests.</description>\n   * ```ts\n   * // /app/shopify.server.ts\n   * import { LATEST_API_VERSION, shopifyApp } from \"@shopify/shopify-app-remix/server\";\n   *\n   * const shopify = shopifyApp({\n   *   // ...etc\n   * });\n   * export default shopify;\n   * ```\n   * ```ts\n   * // /app/routes/auth/login.tsx\n   * import shopify from \"../../shopify.server\";\n   *\n   * export async function loader({ request }: LoaderFunctionArgs) {\n   *   const errors = shopify.login(request);\n   *\n   *   return json(errors);\n   * }\n   *\n   * export async function action({ request }: ActionFunctionArgs) {\n   *   const errors = shopify.login(request);\n   *\n   *   return json(errors);\n   * }\n   *\n   * export default function Auth() {\n   *   const actionData = useActionData<typeof action>();\n   *   const [shop, setShop] = useState(\"\");\n   *\n   *   return (\n   *     <Page>\n   *       <Card>\n   *         <Form method=\"post\">\n   *           <FormLayout>\n   *             <Text variant=\"headingMd\" as=\"h2\">\n   *               Login\n   *             </Text>\n   *             <TextField\n   *               type=\"text\"\n   *               name=\"shop\"\n   *               label=\"Shop domain\"\n   *               helpText=\"e.g: my-shop-domain.myshopify.com\"\n   *               value={shop}\n   *               onChange={setShop}\n   *               autoComplete=\"on\"\n   *               error={actionData?.errors.shop}\n   *             />\n   *             <Button submit primary>\n   *               Submit\n   *             </Button>\n   *           </FormLayout>\n   *         </Form>\n   *       </Card>\n   *     </Page>\n   *   );\n   * }\n   * ```\n   */\n  login: Login;\n}\n\nexport type AdminApp<Config extends AppConfigArg> = ShopifyAppBase<Config>;\nexport type SingleMerchantApp<Config extends AppConfigArg> =\n  ShopifyAppBase<Config> & ShopifyAppLogin;\nexport type AppStoreApp<Config extends AppConfigArg> = ShopifyAppBase<Config> &\n  ShopifyAppLogin;\n\ntype EnforceSessionStorage<Config extends AppConfigArg, Base> = Base & {\n  sessionStorage: SessionStorageType<Config>;\n};\n\n/**\n * An object your app can use to interact with Shopify.\n *\n * By default, the app's distribution is `AppStore`.\n */\nexport type ShopifyApp<Config extends AppConfigArg> =\n  Config['distribution'] extends AppDistribution.ShopifyAdmin\n    ? AdminApp<Config>\n    : Config['distribution'] extends AppDistribution.SingleMerchant\n      ? EnforceSessionStorage<Config, SingleMerchantApp<Config>>\n      : Config['distribution'] extends AppDistribution.AppStore\n        ? EnforceSessionStorage<Config, AppStoreApp<Config>>\n        : EnforceSessionStorage<Config, AppStoreApp<Config>>;\n", "export const SHOPIFY_REMIX_LIBRARY_VERSION = '3.8.5';\n", "import type {BasicParams} from '../../types';\n\nimport type {RegisterWebhooksOptions} from './types';\n\nexport function registerWebhooksFactory({api, logger}: BasicParams) {\n  return async function registerWebhooks({session}: RegisterWebhooksOptions) {\n    return api.webhooks\n      .register({session})\n      .then((response) => {\n        Object.entries(response).forEach(([topic, topicResults]) => {\n          topicResults.forEach(({success, ...rest}) => {\n            if (success) {\n              logger.debug('Registered webhook', {\n                topic,\n                shop: session.shop,\n                operation: rest.operation,\n              });\n            } else {\n              logger.error('Failed to register webhook', {\n                topic,\n                shop: session.shop,\n                result: JSON.stringify(rest.result),\n              });\n            }\n          });\n        });\n\n        return response;\n      })\n      .catch((error) => {\n        const graphQLErrors: {extensions: {code?: string}}[] =\n          error.body?.errors?.graphQLErrors || [];\n\n        const throttled = graphQLErrors.find(\n          ({extensions: {code}}) => code === 'THROTTLED',\n        );\n\n        if (throttled) {\n          logger.error('Failed to register webhooks', {\n            shop: session.shop,\n            error: JSON.stringify(error),\n          });\n        } else {\n          throw error;\n        }\n      });\n  };\n}\n", "export const APP_BRIDGE_URL =\n  'https://cdn.shopify.com/shopifycloud/app-bridge.js';\n\nexport const REAUTH_URL_HEADER =\n  'X-Shopify-API-Request-Failure-Reauthorize-Url';\n\nexport const RETRY_INVALID_SESSION_HEADER = {\n  'X-Shopify-Retry-Invalid-Session-Request': '1',\n};\n\nexport const CORS_HEADERS = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'Authorization',\n  'Access-Control-Expose-Headers': REAUTH_URL_HEADER,\n};\n", "import {BasicParams} from '../../types';\nimport {REAUTH_URL_HEADER} from '../const';\n\nexport interface EnsureCORSFunction {\n  (response: Response): Response;\n}\n\nexport function ensureCORSHeadersFactory(\n  params: BasicParams,\n  request: Request,\n  corsHeaders: string[] = [],\n): EnsureCORSFunction {\n  const {logger, config} = params;\n\n  return function ensureCORSHeaders(response) {\n    const origin = request.headers.get('Origin');\n    if (origin && origin !== config.appUrl) {\n      logger.debug(\n        'Request comes from a different origin, adding CORS headers',\n      );\n\n      const corsHeadersSet = new Set([\n        'Authorization',\n        'Content-Type',\n        ...corsHeaders,\n      ]);\n\n      response.headers.set('Access-Control-Allow-Origin', '*');\n      response.headers.set(\n        'Access-Control-Allow-Headers',\n        [...corsHeadersSet].join(', '),\n      );\n      response.headers.set('Access-Control-Expose-Headers', REAUTH_URL_HEADER);\n    }\n\n    return response;\n  };\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\n\nexport const redirectToBouncePage = (params: BasicParams, url: URL): never => {\n  const {config} = params;\n\n  // Make sure we always point to the configured app URL so it also works behind reverse proxies (that alter the Host\n  // header).\n  const searchParams = url.searchParams;\n  searchParams.delete('id_token');\n  searchParams.set(\n    'shopify-reload',\n    `${config.appUrl}${url.pathname}?${searchParams.toString()}`,\n  );\n\n  // eslint-disable-next-line no-warning-comments\n  // TODO Make sure this works on chrome without a tunnel (weird HTTPS redirect issue)\n  // https://github.com/orgs/Shopify/projects/6899/views/1?pane=issue&itemId=28376650\n  throw redirect(\n    `${config.auth.patchSessionTokenPath}?${searchParams.toString()}`,\n  );\n};\n", "import {redirectToBouncePage} from '../admin/helpers/redirect-to-bounce-page';\nimport {RETRY_INVALID_SESSION_HEADER} from '../const';\nimport {BasicParams} from '../../types';\n\ninterface RespondToInvalidSessionTokenParams {\n  params: BasicParams;\n  request: Request;\n  retryRequest?: boolean;\n}\n\nexport function respondToInvalidSessionToken({\n  params,\n  request,\n  retryRequest = false,\n}: RespondToInvalidSessionTokenParams) {\n  const {api, logger, config} = params;\n\n  const isDocumentRequest = !request.headers.get('authorization');\n  if (isDocumentRequest) {\n    return redirectToBouncePage({api, logger, config}, new URL(request.url));\n  }\n\n  throw new Response(undefined, {\n    status: 401,\n    statusText: 'Unauthorized',\n    headers: retryRequest ? RETRY_INVALID_SESSION_HEADER : {},\n  });\n}\n", "export function getShopFromRequest(request: Request) {\n  const url = new URL(request.url);\n  return url.searchParams.get('shop')!;\n}\n", "import {JwtPayload} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\n\nimport {respondToInvalidSessionToken} from './respond-to-invalid-session-token';\nimport {getShopFromRequest} from './get-shop-from-request';\n\ninterface ValidateSessionTokenOptions {\n  checkAudience?: boolean;\n  retryRequest?: boolean;\n}\n\nexport async function validateSessionToken(\n  params: BasicParams,\n  request: Request,\n  token: string,\n  {checkAudience = true, retryRequest = true}: ValidateSessionTokenOptions = {},\n): Promise<JwtPayload> {\n  const {api, logger} = params;\n  const shop = getShopFromRequest(request);\n  logger.debug('Validating session token', {shop});\n\n  try {\n    const payload = await api.session.decodeSessionToken(token, {\n      checkAudience,\n    });\n    logger.debug('Session token is valid - validated', {\n      shop,\n      payload: JSON.stringify(payload),\n    });\n\n    return payload;\n  } catch (error) {\n    logger.debug(`Failed to validate session token: ${error.message}`, {\n      shop,\n    });\n\n    throw respondToInvalidSessionToken({params, request, retryRequest});\n  }\n}\n", "const SESSION_TOKEN_PARAM = 'id_token';\n\nexport function getSessionTokenHeader(request: Request): string | undefined {\n  return request.headers.get('authorization')?.replace('Bearer ', '');\n}\n\nexport function getSessionTokenFromUrlParam(request: Request): string | null {\n  const url = new URL(request.url);\n\n  return url.searchParams.get(SESSION_TOKEN_PARAM);\n}\n", "import {isbot} from 'isbot';\n\nimport type {BasicParams} from '../../types';\n\nconst SHOPIFY_POS_USER_AGENT = /Shopify POS\\//;\nconst SHOPIFY_MOBILE_USER_AGENT = /Shopify Mobile\\//;\n\nconst SHOPIFY_USER_AGENTS = [SHOPIFY_POS_USER_AGENT, SHOPIFY_MOBILE_USER_AGENT];\n\nexport function respondToBotRequest(\n  {logger}: BasicParams,\n  request: Request,\n): void | never {\n  const userAgent = request.headers.get('User-Agent') ?? '';\n\n  // We call isbot below to prevent good (self-identifying) bots from triggering auth requests, but there are some\n  // Shopify-specific cases we want to allow that are identified as bots by isbot.\n  if (SHOPIFY_USER_AGENTS.some((agent) => agent.test(userAgent))) {\n    logger.debug('Request is from a Shopify agent, allow');\n    return;\n  }\n\n  if (isbot(userAgent)) {\n    logger.debug('Request is from a bot, skipping auth');\n    throw new Response(undefined, {status: 410, statusText: 'Gone'});\n  }\n}\n", "import {BasicParams} from '../../types';\n\nimport {ensureCORSHeadersFactory} from './ensure-cors-headers';\n\nexport function respondToOptionsRequest(\n  params: BasicParams,\n  request: Request,\n  corsHeaders?: string[],\n) {\n  if (request.method === 'OPTIONS') {\n    const ensureCORSHeaders = ensureCORSHeadersFactory(\n      params,\n      request,\n      corsHeaders,\n    );\n\n    throw ensureCORSHeaders(\n      new Response(null, {\n        status: 204,\n        headers: {\n          'Access-Control-Max-Age': '7200',\n        },\n      }),\n    );\n  }\n}\n", "import type {BasicParams} from '../../../types';\n\nexport async function beginAuth(\n  params: BasicParams,\n  request: Request,\n  isOnline: boolean,\n  shop: string,\n): Promise<never> {\n  const {api, config} = params;\n\n  throw await api.auth.begin({\n    shop,\n    callbackPath: config.auth.callbackPath,\n    isOnline,\n    rawRequest: request,\n  });\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport type {BasicParams} from '../../../types';\n\nexport function redirectWithExitIframe(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n): never {\n  const {api, config} = params;\n  const url = new URL(request.url);\n\n  const queryParams = url.searchParams;\n\n  const host = api.utils.sanitizeHost(queryParams.get('host')!);\n\n  queryParams.set('shop', shop);\n\n  let destination = `${config.auth.path}?shop=${shop}`;\n\n  if (host) {\n    queryParams.set('host', host);\n    destination = `${destination}&host=${host}`;\n  }\n  queryParams.set('exitIframe', destination);\n\n  throw redirect(`${config.auth.exitIframePath}?${queryParams.toString()}`);\n}\n", "import {REAUTH_URL_HEADER} from '../../const';\n\nexport function redirectWithAppBridgeHeaders(redirectUri: string): never {\n  throw new Response(undefined, {\n    status: 401,\n    statusText: 'Unauthorized',\n    headers: getAppBridgeHeaders(redirectUri),\n  });\n}\n\nexport function getAppBridgeHeaders(url: string) {\n  return new Headers({[REAUTH_URL_HEADER]: url});\n}\n", "import type {BasicParams} from '../../../types';\n\nimport {beginAuth} from './begin-auth';\nimport {redirectWithExitIframe} from './redirect-with-exitiframe';\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport async function redirectToAuthPage(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n  isOnline = false,\n): Promise<never> {\n  const {config} = params;\n\n  const url = new URL(request.url);\n  const isEmbeddedRequest = url.searchParams.get('embedded') === '1';\n  const isXhrRequest = request.headers.get('authorization');\n\n  if (isXhrRequest) {\n    const redirectUri = new URL(config.auth.path, config.appUrl);\n    redirectUri.searchParams.set('shop', shop);\n    redirectWithAppBridgeHeaders(redirectUri.toString());\n  } else if (isEmbeddedRequest) {\n    redirectWithExitIframe(params, request, shop);\n  } else {\n    throw await beginAuth(params, request, isOnline, shop);\n  }\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\n\nexport async function invalidateAccessToken(\n  params: BasicParams,\n  session: Session,\n): Promise<void> {\n  const {logger, config} = params;\n\n  logger.debug(`Invalidating access token for session - ${session.id}`, {\n    shop: session.shop,\n  });\n\n  session.accessToken = undefined;\n  await config.sessionStorage!.storeSession(session);\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {CancelBillingOptions} from './types';\n\nexport function cancelBillingFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function cancelBilling(options: CancelBillingOptions) {\n    const {api, logger} = params;\n\n    logger.debug('Cancelling billing', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.cancel({\n        session,\n        subscriptionId: options.subscriptionId,\n        isTest: options.isTest,\n        prorate: options.prorate,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {\n  BillingCheckResponseObject,\n  HttpResponseError,\n  Session,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport type {AppConfigArg} from '../../../config-types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {RequireBillingOptions} from './types';\n\nexport function requireBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  const {api, logger} = params;\n\n  return async function requireBilling(options: RequireBillingOptions<Config>) {\n    const logContext = {\n      shop: session.shop,\n      plans: options.plans,\n      isTest: options.isTest,\n    };\n\n    logger.debug('Checking billing for the shop', logContext);\n\n    let data: BillingCheckResponseObject;\n    try {\n      data = await api.billing.check({\n        session,\n        plans: options.plans as string[],\n        isTest: options.isTest,\n        returnObject: true,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', logContext);\n\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n\n    if (!data.hasActivePayment) {\n      logger.debug('Billing check failed', logContext);\n      throw await options.onFailure(new Error('Billing check failed'));\n    }\n\n    logger.debug('Billing check succeeded', logContext);\n\n    return data;\n  };\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\nimport {getAppBridgeHeaders} from '../helpers';\n\nexport function redirectOutOfApp(\n  params: BasicParams,\n  request: Request,\n  url: string,\n  shop: string,\n): never {\n  const {config, logger} = params;\n\n  logger.debug('Redirecting out of app', {shop, url});\n\n  const requestUrl = new URL(request.url);\n  const isEmbeddedRequest = requestUrl.searchParams.get('embedded') === '1';\n  const isXhrRequest = request.headers.get('authorization');\n\n  if (isXhrRequest) {\n    // eslint-disable-next-line no-warning-comments\n    // TODO Check this with the beta flag disabled (with the bounce page)\n    // Remix is not including the X-Shopify-API-Request-Failure-Reauthorize-Url when throwing a Response\n    // https://github.com/remix-run/remix/issues/5356\n    throw new Response(undefined, {\n      status: 401,\n      statusText: 'Unauthorized',\n      headers: getAppBridgeHeaders(url),\n    });\n  } else if (isEmbeddedRequest) {\n    const params = new URLSearchParams({\n      shop,\n      host: requestUrl.searchParams.get('host')!,\n      exitIframe: url,\n    });\n\n    throw redirect(`${config.auth.exitIframePath}?${params.toString()}`);\n  } else {\n    // This will only ever happen for non-embedded apps, because the authenticator will stop before reaching this point\n    throw redirect(url);\n  }\n}\n", "import {\n  BillingRequestResponseObject,\n  HttpResponseError,\n  Session,\n} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport {redirectOutOfApp} from './helpers';\nimport type {RequestBillingOptions} from './types';\n\nexport function requestBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function requestBilling({\n    plan,\n    isTest,\n    returnUrl,\n    ...overrides\n  }: RequestBillingOptions<Config>): Promise<never> {\n    const {api, logger} = params;\n\n    logger.info('Requesting billing', {\n      shop: session.shop,\n      plan,\n      isTest,\n      returnUrl,\n    });\n\n    let result: BillingRequestResponseObject;\n    try {\n      result = await api.billing.request({\n        plan: plan as string,\n        session,\n        isTest,\n        returnUrl,\n        returnObject: true,\n        ...overrides,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n\n    throw redirectOutOfApp(\n      params,\n      request,\n      result.confirmationUrl,\n      session.shop,\n    );\n  };\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport type {AppConfigArg} from '../../../config-types';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {CheckBillingOptions} from './types';\n\nexport function checkBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function checkBilling(\n    options: CheckBillingOptions<Config> = {},\n  ) {\n    const {api, logger} = params;\n\n    logger.debug('Checking billing plans', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.check({\n        session,\n        plans: options.plans as string[],\n        isTest: options.isTest,\n        returnObject: true,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport type {CreateUsageRecordOptions} from './types';\n\nexport function createUsageRecordFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function createUsageRecord(options: CreateUsageRecordOptions) {\n    const {api, logger} = params;\n\n    logger.debug('Create usage record', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.createUsageRecord({\n        ...options,\n        session,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n", "import {\n  HttpResponseError,\n  Session,\n  UpdateCappedAmountConfirmation,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToAuthPage} from '../helpers';\nimport {invalidateAccessToken} from '../../helpers';\n\nimport {UpdateUsageCappedAmountOptions} from './types';\nimport {redirectOutOfApp} from './helpers';\n\nexport function updateUsageCappedAmountFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function updateUsageCappedAmount(\n    options: UpdateUsageCappedAmountOptions,\n  ): Promise<never> {\n    const {api, logger} = params;\n\n    logger.debug('Updating usage subscription capped amount', {\n      shop: session.shop,\n      ...options,\n    });\n\n    let result: UpdateCappedAmountConfirmation;\n    try {\n      result = await api.billing.updateUsageCappedAmount({\n        session,\n        subscriptionLineItemId: options.subscriptionLineItemId,\n        cappedAmount: options.cappedAmount,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, redirecting to OAuth', {\n          shop: session.shop,\n        });\n        await invalidateAccessToken(params, session);\n        throw await redirectToAuthPage(params, request, session.shop);\n      } else {\n        throw error;\n      }\n    }\n\n    throw redirectOutOfApp(\n      params,\n      request,\n      result.confirmationUrl,\n      session.shop,\n    );\n  };\n}\n", "import {AdminOperations} from '@shopify/admin-api-client';\n\nimport {GraphQLClient} from '../types';\n\nimport {AdminClientOptions} from './types';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: This is actually just a call through to the Shopify API client, but with a different API. We should eventually\n// move this over to the library layer. While doing that, we should also allow the apiVersion to be passed into the REST\n// client request calls.\nexport function graphqlClientFactory({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): GraphQLClient<AdminOperations> {\n  return async function query(operation, options) {\n    const client = new params.api.clients.Graphql({\n      session,\n      apiVersion: options?.apiVersion,\n    });\n\n    try {\n      // We convert the incoming response to a Response object to bring this client closer to the Remix client.\n      const apiResponse = await client.request(operation, {\n        variables: options?.variables,\n        retries: options?.tries ? options.tries - 1 : 0,\n        headers: options?.headers,\n        signal: options?.signal,\n      });\n\n      return new Response(JSON.stringify(apiResponse));\n    } catch (error) {\n      if (handleClientError) {\n        throw await handleClientError({error, params, session});\n      }\n\n      throw error;\n    }\n  };\n}\n", "import {\n  DeleteRequestParams,\n  GetRequestParams,\n  PostRequestParams,\n  PutRequestParams,\n  RequestParams,\n  Session,\n  Shopify,\n  ShopifyRestResources,\n} from '@shopify/shopify-api';\n\nimport type {AdminClientOptions} from './types';\n\nexport type RestClientWithResources<Resources extends ShopifyRestResources> =\n  RemixRestClient & {resources: Resources};\n\nexport function restClientFactory<\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): RestClientWithResources<Resources> {\n  const {api} = params;\n  const client = new RemixRestClient({\n    params,\n    handleClientError,\n    session,\n  }) as RestClientWithResources<Resources>;\n\n  if (api.rest) {\n    client.resources = {} as Resources;\n\n    const RestResourceClient = restResourceClientFactory({\n      params,\n      handleClientError,\n      session,\n    });\n\n    Object.entries(api.rest).forEach(([name, resource]) => {\n      class RemixResource extends resource {\n        public static Client = RestResourceClient;\n      }\n\n      Reflect.defineProperty(RemixResource, 'name', {\n        value: name,\n      });\n\n      Reflect.set(client.resources, name, RemixResource);\n    });\n  }\n\n  return client;\n}\n\nclass RemixRestClient {\n  public session: Session;\n  private params: AdminClientOptions['params'];\n  private handleClientError: AdminClientOptions['handleClientError'];\n\n  constructor({params, session, handleClientError}: AdminClientOptions) {\n    this.params = params;\n    this.handleClientError = handleClientError;\n    this.session = session;\n  }\n\n  /**\n   * Performs a GET request on the given path.\n   *\n   * @deprecated In a future major release REST will be removed from this package. Please see [all-in on graphql](https://www.shopify.com/ca/partners/blog/all-in-on-graphql).\n   */\n  public async get(params: GetRequestParams) {\n    return this.makeRequest({\n      method: 'GET' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a POST request on the given path.\n   *\n   * @deprecated In a future major release REST will be removed from this package. Please see [all-in on graphql](https://www.shopify.com/ca/partners/blog/all-in-on-graphql).\n   */\n  public async post(params: PostRequestParams) {\n    return this.makeRequest({\n      method: 'POST' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a PUT request on the given path.\n   *\n   * @deprecated In a future major release REST will be removed from this package. Please see [all-in on graphql](https://www.shopify.com/ca/partners/blog/all-in-on-graphql).\n   */\n  public async put(params: PutRequestParams) {\n    return this.makeRequest({\n      method: 'PUT' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  /**\n   * Performs a DELETE request on the given path.\n   *\n   * @deprecated In a future major release REST will be removed from this package. Please see [all-in on graphql](https://www.shopify.com/ca/partners/blog/all-in-on-graphql).\n   */\n  public async delete(params: DeleteRequestParams) {\n    return this.makeRequest({\n      method: 'DELETE' as RequestParams['method'],\n      ...params,\n    });\n  }\n\n  protected async makeRequest(params: RequestParams): Promise<Response> {\n    const originalClient = new this.params.api.clients.Rest({\n      session: this.session,\n    });\n    const originalRequest = Reflect.get(originalClient, 'request');\n\n    try {\n      const apiResponse = await originalRequest.call(originalClient, params);\n\n      // We use a separate client for REST requests and REST resources because we want to override the API library\n      // client class to return a Response object instead.\n      return new Response(JSON.stringify(apiResponse.body), {\n        headers: apiResponse.headers,\n      });\n    } catch (error) {\n      if (this.handleClientError) {\n        throw await this.handleClientError({\n          error,\n          session: this.session,\n          params: this.params,\n        });\n      } else throw new Error(error);\n    }\n  }\n}\n\nfunction restResourceClientFactory({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): Shopify['clients']['Rest'] {\n  const {api} = params;\n\n  const ApiClient = api.clients.Rest;\n  return class RestResourceClient extends ApiClient {\n    protected async request(requestParams: RequestParams) {\n      const originalClient = new api.clients.Rest({session});\n      const originalRequest = Reflect.get(originalClient, 'request');\n\n      try {\n        // We just call through to the API library client, and handle the error response here, so that data parsing\n        // behaves the same way.\n        return await originalRequest.call(originalClient, requestParams);\n      } catch (error) {\n        if (handleClientError) {\n          throw await handleClientError({error, params, session});\n        } else throw new Error(error);\n      }\n    }\n  };\n}\n", "import {Session, ShopifyRestResources} from '@shopify/shopify-api';\n\nimport type {AppConfigArg} from '../../config-types';\nimport {BasicParams} from '../../types';\n\nimport {graphqlClientFactory} from './graphql';\nimport {restClientFactory} from './rest';\nimport type {AdminApiContext} from './types';\n\ninterface RestClientOptions {\n  params: BasicParams;\n  session: Session;\n  handleClientError?: (error: any) => Promise<void>;\n}\n\nexport function adminClientFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>({\n  params,\n  handleClientError,\n  session,\n}: RestClientOptions): AdminApiContext<ConfigArg, Resources> {\n  if (params.config.future.removeRest) {\n    return {\n      graphql: graphqlClientFactory({params, session, handleClientError}),\n    } as AdminApiContext<ConfigArg, Resources>;\n  }\n\n  return {\n    rest: restClientFactory<Resources>({\n      params,\n      session,\n      handleClientError,\n    }),\n    graphql: graphqlClientFactory({params, session, handleClientError}),\n  } as AdminApiContext<ConfigArg, Resources>;\n}\n", "import {Session, ShopifyRestResources} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport type {BasicParams} from '../../../types';\nimport {\n  AdminApiContext,\n  HandleAdminClientError,\n  adminClientFactory,\n} from '../../../clients/admin';\n\nexport function createAdminApiContext<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>(\n  session: Session,\n  params: BasicParams,\n  handleClientError: HandleAdminClientError,\n): AdminApiContext<ConfigArg, Resources> {\n  return adminClientFactory<ConfigArg, Resources>({\n    session,\n    params,\n    handleClientError,\n  });\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport type {BasicParams} from '../../../types';\n\nexport async function redirectToShopifyOrAppRoot(\n  request: Request,\n  params: BasicParams,\n  responseHeaders?: Headers,\n): Promise<never> {\n  const {api} = params;\n  const url = new URL(request.url);\n\n  const host = api.utils.sanitizeHost(url.searchParams.get('host')!)!;\n  const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!)!;\n\n  const redirectUrl = api.config.isEmbeddedApp\n    ? await api.auth.getEmbeddedAppUrl({rawRequest: request})\n    : `/?shop=${shop}&host=${encodeURIComponent(host)}`;\n\n  throw redirect(redirectUrl, {headers: responseHeaders});\n}\n", "import {BasicParams} from '../../../types';\n\nimport {redirectToShopifyOrAppRoot} from './redirect-to-shopify-or-app-root';\n\nexport const ensureAppIsEmbeddedIfRequired = async (\n  params: BasicParams,\n  request: Request,\n) => {\n  const {api, logger, config} = params;\n  const url = new URL(request.url);\n\n  const shop = url.searchParams.get('shop')!;\n\n  if (api.config.isEmbeddedApp && url.searchParams.get('embedded') !== '1') {\n    logger.debug('App is not embedded, redirecting to Shopify', {shop});\n    await redirectToShopifyOrAppRoot(request, {api, logger, config});\n  }\n};\n", "import {BasicParams} from '../../../types';\n\nimport {redirectToBouncePage} from './redirect-to-bounce-page';\n\nconst SESSION_TOKEN_PARAM = 'id_token';\n\nexport const ensureSessionTokenSearchParamIfRequired = async (\n  params: BasicParams,\n  request: Request,\n) => {\n  const {api, logger} = params;\n  const url = new URL(request.url);\n\n  const shop = url.searchParams.get('shop')!;\n  const searchParamSessionToken = url.searchParams.get(SESSION_TOKEN_PARAM);\n  const isEmbedded = url.searchParams.get('embedded') === '1';\n\n  if (api.config.isEmbeddedApp && isEmbedded && !searchParamSessionToken) {\n    logger.debug(\n      'Missing session token in search params, going to bounce page',\n      {shop},\n    );\n    redirectToBouncePage(params, url);\n  }\n};\n", "import {APP_BRIDGE_URL} from '../const';\n\nlet appBridgeUrlOverride: string | undefined;\nexport function setAppBridgeUrlOverride(url: string) {\n  appBridgeUrlOverride = url;\n}\n\nexport function appBridgeUrl() {\n  return appBridgeUrlOverride || APP_BRIDGE_URL;\n}\n", "import type {BasicParams} from '../../types';\n\nexport type AddDocumentResponseHeadersFunction = (\n  request: Request,\n  headers: Headers,\n) => void;\n\nexport function addDocumentResponseHeadersFactory(\n  params: BasicParams,\n): AddDocumentResponseHeadersFunction {\n  const {api, config} = params;\n\n  return function (request: Request, headers: Headers) {\n    const {searchParams} = new URL(request.url);\n    const shop = api.utils.sanitizeShop(searchParams.get('shop')!);\n\n    addDocumentResponseHeaders(headers, config.isEmbeddedApp, shop);\n  };\n}\n\nexport function addDocumentResponseHeaders(\n  headers: Headers,\n  isEmbeddedApp: boolean,\n  shop: string | null | undefined,\n) {\n  if (shop) {\n    headers.set(\n      'Link',\n      '<https://cdn.shopify.com/shopifycloud/app-bridge.js>; rel=\"preload\"; as=\"script\";',\n    );\n  }\n\n  if (isEmbeddedApp) {\n    if (shop) {\n      headers.set(\n        'Content-Security-Policy',\n        `frame-ancestors https://${shop} https://admin.shopify.com https://*.spin.dev https://admin.myshopify.io https://admin.shop.dev;`,\n      );\n    }\n  } else {\n    headers.set('Content-Security-Policy', `frame-ancestors 'none';`);\n  }\n}\n", "import {ShopifyError} from '@shopify/shopify-api';\n\ninterface Options {\n  requireSSL?: boolean;\n  throwOnInvalid?: boolean;\n}\n\ntype SanitizedRedirectUrl<OptionsArg extends Options> =\n  OptionsArg['throwOnInvalid'] extends false ? URL | undefined : URL;\n\nconst FILE_URI_MATCH = /\\/\\/\\//;\nconst INVALID_RELATIVE_URL = /[/\\\\][/\\\\]/;\nconst WHITESPACE_CHARACTER = /\\s/;\nconst VALID_PROTOCOLS = ['https:', 'http:'];\n\nfunction isSafe(\n  domain: string,\n  redirectUrl: unknown,\n  requireSSL: boolean | undefined = true,\n): redirectUrl is string {\n  if (typeof redirectUrl !== 'string') {\n    return false;\n  }\n\n  if (\n    FILE_URI_MATCH.test(redirectUrl) ||\n    WHITESPACE_CHARACTER.test(redirectUrl)\n  ) {\n    return false;\n  }\n\n  let url: URL;\n\n  try {\n    url = new URL(redirectUrl, domain);\n  } catch (error) {\n    return false;\n  }\n\n  if (INVALID_RELATIVE_URL.test(url.pathname)) {\n    return false;\n  }\n\n  if (!VALID_PROTOCOLS.includes(url.protocol)) {\n    return false;\n  }\n\n  if (requireSSL && url.protocol !== 'https:') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function sanitizeRedirectUrl<OptionsArg extends Options>(\n  domain: string,\n  redirectUrl: unknown,\n  options: OptionsArg = {} as OptionsArg,\n): SanitizedRedirectUrl<OptionsArg> {\n  if (isSafe(domain, redirectUrl, options.requireSSL)) {\n    return new URL(redirectUrl, domain) as SanitizedRedirectUrl<OptionsArg>;\n  } else if (options.throwOnInvalid === false) {\n    return undefined as SanitizedRedirectUrl<OptionsArg>;\n  } else {\n    throw new ShopifyError('Invalid URL. Refusing to redirect');\n  }\n}\n", "import {BasicParams} from '../../../types';\nimport {appBridgeUrl} from '../../helpers/app-bridge-url';\nimport {addDocumentResponseHeaders} from '../../helpers/add-response-headers';\n\nimport {sanitizeRedirectUrl} from './validate-redirect-url';\n\nimport type {RedirectTarget} from '.';\n\nexport interface RedirectToOptions {\n  url: string | URL;\n  target?: RedirectTarget;\n}\n\nexport function renderAppBridge(\n  {config}: BasicParams,\n  request: Request,\n  redirectTo?: RedirectToOptions,\n): never {\n  let redirectToScript = '';\n  if (redirectTo) {\n    const destination = sanitizeRedirectUrl(config.appUrl, redirectTo.url);\n\n    const target = redirectTo.target ?? '_top';\n\n    redirectToScript = `<script>window.open(${JSON.stringify(\n      destination.toString(),\n    )}, ${JSON.stringify(target)})</script>`;\n  }\n\n  const responseHeaders = new Headers({\n    'content-type': 'text/html;charset=utf-8',\n  });\n  addDocumentResponseHeaders(\n    responseHeaders,\n    config.isEmbeddedApp,\n    new URL(request.url).searchParams.get('shop'),\n  );\n\n  throw new Response(\n    `\n      <script data-api-key=\"${config.apiKey}\" src=\"${appBridgeUrl()}\"></script>\n      ${redirectToScript}\n    `,\n    {headers: responseHeaders},\n  );\n}\n", "import {\n  TypedResponse,\n  redirect as remixRedirect,\n} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\nimport {getSessionTokenHeader} from '../../helpers/get-session-token-header';\n\nimport {renderAppBridge} from './render-app-bridge';\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport type RedirectTarget = '_self' | '_parent' | '_top' | '_blank';\nexport type RedirectInit = number | (ResponseInit & {target?: RedirectTarget});\nexport type RedirectFunction = (\n  url: string,\n  init?: RedirectInit,\n) => TypedResponse<never>;\n\ninterface ParseURLOptions {\n  params: BasicParams;\n  url: string;\n  base: string;\n  shop: string;\n  init: RedirectInit;\n}\n\ninterface ParsedURL {\n  url: URL;\n  target: RedirectTarget;\n}\n\nexport function redirectFactory(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n): RedirectFunction {\n  const {config, logger} = params;\n\n  return function redirect(url, init: RedirectInit) {\n    const {searchParams} = new URL(request.url);\n    const {url: parsedUrl, target} = parseURL({\n      params,\n      url,\n      base: config.appUrl,\n      shop,\n      init,\n    });\n\n    logger.debug('Redirecting', {shop, url: parsedUrl.toString()});\n\n    const isSameOrigin = parsedUrl.origin === config.appUrl;\n    if (isSameOrigin || url.startsWith('/')) {\n      searchParams.forEach((value, key) => {\n        if (!parsedUrl.searchParams.has(key)) {\n          parsedUrl.searchParams.set(key, value);\n        }\n      });\n    }\n\n    if (target === '_self') {\n      if (isBounceRequest(request)) {\n        throw renderAppBridge(params, request, {\n          url: parsedUrl.toString(),\n          target,\n        });\n      } else {\n        return remixRedirect(parsedUrl.toString(), init);\n      }\n    } else if (isDataRequest(request)) {\n      throw redirectWithAppBridgeHeaders(parsedUrl.toString());\n    } else if (isEmbeddedRequest(request)) {\n      throw renderAppBridge(params, request, {\n        url: parsedUrl.toString(),\n        target,\n      });\n    }\n    return remixRedirect(url, init);\n  };\n}\n\nfunction isBounceRequest(request: Request) {\n  return (\n    Boolean(getSessionTokenHeader(request)) &&\n    request.headers.has('X-Shopify-Bounce')\n  );\n}\n\nfunction isDataRequest(request: Request) {\n  const isGet = request.method === 'GET';\n  const sessionTokenHeader = Boolean(getSessionTokenHeader(request));\n\n  return (\n    sessionTokenHeader &&\n    !isBounceRequest(request) &&\n    (!isEmbeddedRequest(request) || !isGet)\n  );\n}\n\nfunction isEmbeddedRequest(request: Request) {\n  const {searchParams} = new URL(request.url);\n\n  return searchParams.get('embedded') === '1';\n}\n\nfunction parseURL({params, base, init, shop, url}: ParseURLOptions): ParsedURL {\n  let target: RedirectTarget | undefined =\n    typeof init !== 'number' && init?.target ? init.target : undefined;\n\n  if (isAdminRemotePath(url)) {\n    const {config} = params;\n\n    const adminPath = getAdminRemotePath(url);\n    const cleanShopName = shop.replace('.myshopify.com', '');\n\n    if (!target) {\n      target = config.isEmbeddedApp ? '_parent' : '_self';\n    }\n\n    return {\n      url: new URL(\n        `https://admin.shopify.com/store/${cleanShopName}${adminPath}`,\n      ),\n      target,\n    };\n  } else {\n    return {\n      url: new URL(url, base),\n      target: target ?? '_self',\n    };\n  }\n}\n\nconst ADMIN_REGEX = /^shopify:\\/*admin\\//i;\n\nfunction isAdminRemotePath(url: string) {\n  return ADMIN_REGEX.test(url);\n}\n\nfunction getAdminRemotePath(url: string | URL) {\n  const parsedUrl = removeRestrictedParams(new URL(url)).href;\n  return parsedUrl.replace(ADMIN_REGEX, '/');\n}\n\nconst embeddedFrameParamsToRemove = [\n  'hmac',\n  'locale',\n  'protocol',\n  'session',\n  'id_token',\n  'shop',\n  'timestamp',\n  'host',\n  'embedded',\n  // sent when clicking rel=\"home\" nav item\n  'appLoadId',\n];\n\nfunction removeRestrictedParams(url: URL | string) {\n  const newUrl = new URL(url);\n  embeddedFrameParamsToRemove.forEach((param) =>\n    newUrl.searchParams.delete(param),\n  );\n  return newUrl;\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams} from '../../../types';\n\nexport function validateShopAndHostParams(\n  params: BasicParams,\n  request: Request,\n) {\n  const {api, config, logger} = params;\n\n  if (config.isEmbeddedApp) {\n    const url = new URL(request.url);\n    const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!);\n    if (!shop) {\n      logger.debug('Missing or invalid shop, redirecting to login path', {\n        shop,\n      });\n      throw redirectToLoginPath(request, params);\n    }\n\n    const host = api.utils.sanitizeHost(url.searchParams.get('host')!);\n    if (!host) {\n      logger.debug('Invalid host, redirecting to login path', {\n        shop,\n        host: url.searchParams.get('host'),\n      });\n      throw redirectToLoginPath(request, params);\n    }\n  }\n}\n\nfunction redirectToLoginPath(request: Request, params: BasicParams): never {\n  const {config, logger} = params;\n\n  const {pathname} = new URL(request.url);\n  if (pathname === config.auth.loginPath) {\n    const message =\n      `Detected call to shopify.authenticate.admin() from configured login path ` +\n      `('${config.auth.loginPath}'), please make sure to call shopify.login() from that route instead.`;\n\n    logger.debug(message);\n    throw new Response(message, {status: 500});\n  }\n\n  throw redirect(config.auth.loginPath);\n}\n", "import {redirect as remixRedirect} from '@remix-run/server-runtime';\n\nimport type {BasicParams} from '../../../types';\n\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport async function redirectToInstallPage(\n  params: BasicParams,\n  shop: string,\n  optionalScopes: string[] = [],\n): Promise<never> {\n  const installUrl = buildInstallUrl(params, shop, optionalScopes);\n  if (params.config.isEmbeddedApp) {\n    throw redirectWithAppBridgeHeaders(installUrl);\n  } else {\n    throw remixRedirect(installUrl);\n  }\n}\n\nfunction buildInstallUrl(\n  params: BasicParams,\n  shop: string,\n  optionalScopes: string[] = [],\n) {\n  const baseInstallUrl = buildBaseInstallUrl(params, shop);\n  baseInstallUrl.search = buildParamsInstallUrl(\n    params,\n    optionalScopes,\n  ).toString();\n  return baseInstallUrl.href;\n}\n\nfunction buildBaseInstallUrl({api}: BasicParams, shop: string) {\n  const cleanShop = api.utils.sanitizeShop(shop, true);\n  return new URL(`https://${cleanShop}/admin/oauth/install`);\n}\n\nfunction buildParamsInstallUrl(\n  {config}: BasicParams,\n  optionalScopes: string[] = [],\n) {\n  const optionalScopesParam =\n    optionalScopes && optionalScopes.length > 0\n      ? {optional_scopes: optionalScopes.join(',')}\n      : undefined;\n\n  const query = {\n    client_id: config.apiKey,\n    scope: config.scopes?.toString() || '',\n    ...optionalScopesParam,\n  };\n  return new URLSearchParams(query);\n}\n", "import {AppConfigArg} from '../../../../config-types';\nimport {AdminApiContext} from '../../../../clients';\n\nexport interface FetchScopesDetailResponse {\n  app: {\n    requestedAccessScopes: {\n      handle: string;\n    }[];\n    optionalAccessScopes: {\n      handle: string;\n    }[];\n    installation: {\n      accessScopes: {\n        handle: string;\n      }[];\n    };\n  };\n}\n\nconst FETCH_SCOPES_DETAIL_QUERY = `#graphql\nquery FetchAccessScopes{\n  app {\n    requestedAccessScopes {\n      handle\n    }\n    optionalAccessScopes {\n      handle\n    }\n    installation {\n      accessScopes {\n        handle\n      }\n    }\n  }\n}`;\n\nexport async function fetchScopeDetail<ConfigArg extends AppConfigArg>(\n  admin: AdminApiContext<ConfigArg>,\n): Promise<FetchScopesDetailResponse> {\n  const fetchScopeDetailResult = await admin.graphql(FETCH_SCOPES_DETAIL_QUERY);\n\n  const resultContent = await fetchScopeDetailResult.json();\n  return resultContent.data;\n}\n", "import {AuthScopes, Session} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport type {BasicParams} from '../../../types';\nimport {redirectToInstallPage} from '../helpers/redirect-to-install-page';\nimport {AdminApiContext} from '../../../clients';\n\nimport {fetchScopeDetail} from './client/fetch-scopes-details';\n\nexport function requestScopesFactory<ConfigArg extends AppConfigArg>(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext<ConfigArg>,\n) {\n  return async function requestScopes(scopes: string[]) {\n    const {logger} = params;\n\n    logger.debug('Requesting optional scopes: ', {shop: session.shop, scopes});\n\n    if (scopes.length === 0) return;\n    if (await alreadyGranted(scopes, admin)) return;\n\n    throw await redirectToInstallPage(params, session.shop, scopes);\n  };\n\n  async function alreadyGranted(\n    scopes: string[],\n    admin: AdminApiContext<ConfigArg>,\n  ) {\n    const scopesDetail = await fetchScopeDetail(admin);\n    const grantedScopes = scopesDetail.app.installation.accessScopes.map(\n      (scope) => scope.handle,\n    );\n    return new AuthScopes(grantedScopes).has(scopes);\n  }\n}\n", "import {AuthScopes, Session} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {AdminApiContext} from '../../../clients';\nimport type {BasicParams} from '../../../types';\n\nimport {ScopesDetail} from './types';\nimport {\n  FetchScopesDetailResponse,\n  fetchScopeDetail,\n} from './client/fetch-scopes-details';\n\nexport function queryScopesFactory<ConfigArg extends AppConfigArg>(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext<ConfigArg>,\n) {\n  return async function queryScopes() {\n    const {logger} = params;\n\n    logger.debug('Querying scopes details: ', {\n      shop: session.shop,\n    });\n\n    const scopesDetail = await fetchScopeDetail(admin);\n    return mapFetchScopeDetail(scopesDetail);\n  };\n}\n\nexport function mapFetchScopeDetail(\n  scopesDetailResponse: FetchScopesDetailResponse,\n): ScopesDetail {\n  const appInformation = scopesDetailResponse.app;\n\n  const granted = new AuthScopes(\n    appInformation.installation.accessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  const required = new AuthScopes(\n    appInformation.requestedAccessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  const optional = new AuthScopes(\n    appInformation.optionalAccessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  return {\n    granted,\n    required,\n    optional,\n  };\n}\n", "import {AppConfigArg} from '../../../../config-types';\nimport {AdminApiContext} from '../../../../clients';\n\nexport interface RevokeScopesResponse {\n  revoked: {\n    handle: string;\n  }[];\n  userErrors: {\n    field: string;\n    message: string;\n  }[];\n}\n\nconst REVOKE_SCOPE_MUTATION = `#graphql\nmutation AppRevokeAccessScopes($scopes: [String!]!) {\n  appRevokeAccessScopes(scopes: $scopes){\n    revoked {\n      handle\n    }\n    userErrors {\n      field\n      message\n    }\n  }\n}`;\n\nexport async function revokeScopes<ConfigArg extends AppConfigArg>(\n  admin: AdminApiContext<ConfigArg>,\n  scopes: string[],\n): Promise<RevokeScopesResponse> {\n  const revokeScopesResult = await admin.graphql(REVOKE_SCOPE_MUTATION, {\n    variables: {\n      scopes,\n    },\n  });\n\n  const resultContent = await revokeScopesResult.json();\n  return resultContent.data.appRevokeAccessScopes;\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {AdminApiContext} from '../../../clients';\nimport type {BasicParams} from '../../../types';\n\nimport {revokeScopes} from './client/revoke-scopes';\n\nexport function revokeScopesFactory<ConfigArg extends AppConfigArg>(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext<ConfigArg>,\n) {\n  return async function revoke(scopes: string[]) {\n    const {logger} = params;\n\n    await validateScopes(scopes);\n\n    logger.debug('Revoke scopes: ', {\n      shop: session.shop,\n      scopes,\n    });\n\n    const revokeScopesResult = await revokeScopes(admin, scopes);\n    if (revokeScopesResult.userErrors?.length > 0) {\n      logger.error('Failed to revoke scopes: ', {\n        shop: session.shop,\n        errors: revokeScopesResult.userErrors,\n      });\n\n      throw new Response(JSON.stringify(revokeScopesResult.userErrors), {\n        status: 422,\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    }\n\n    return {\n      revoked: revokeScopesResult.revoked.map((scope) => scope.handle),\n    };\n  };\n}\n\nasync function validateScopes(scopes: string[]) {\n  if (!scopes || scopes.length === 0) {\n    throw new Response('No scopes provided', {status: 400});\n  }\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {AdminApiContext} from '../../../clients';\n\nimport {ScopesApiContext} from './types';\nimport {requestScopesFactory} from './request';\nimport {queryScopesFactory} from './query';\nimport {revokeScopesFactory} from './revoke';\n\nexport function scopesApiFactory<ConfigArg extends AppConfigArg>(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext<ConfigArg>,\n): ScopesApiContext {\n  return {\n    query: queryScopesFactory(params, session, admin),\n    request: requestScopesFactory(params, session, admin),\n    revoke: revokeScopesFactory(params, session, admin),\n  };\n}\n", "import {JwtPayload, Session, ShopifyRestResources} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\nimport type {AppConfigArg} from '../../config-types';\nimport {\n  getSessionTokenHeader,\n  ensureCORSHeadersFactory,\n  getSessionTokenFromUrlParam,\n  respondToBotRequest,\n  respondToOptionsRequest,\n  validateSessionToken,\n  getShopFromRequest,\n} from '../helpers';\n\nimport {\n  cancelBillingFactory,\n  requestBillingFactory,\n  requireBillingFactory,\n  checkBillingFactory,\n  createUsageRecordFactory,\n  updateUsageCappedAmountFactory,\n} from './billing';\nimport type {\n  AdminContext,\n  AuthenticateAdmin,\n  EmbeddedAdminContext,\n  NonEmbeddedAdminContext,\n} from './types';\nimport {\n  createAdminApiContext,\n  ensureAppIsEmbeddedIfRequired,\n  ensureSessionTokenSearchParamIfRequired,\n  redirectFactory,\n  renderAppBridge,\n  validateShopAndHostParams,\n} from './helpers';\nimport {AuthorizationStrategy} from './strategies/types';\nimport {scopesApiFactory} from './scope/factory';\n\nexport interface SessionTokenContext {\n  shop: string;\n  sessionId?: string;\n  sessionToken?: string;\n  payload?: JwtPayload;\n}\n\ninterface AuthStrategyParams extends BasicParams {\n  strategy: AuthorizationStrategy;\n}\n\nexport function authStrategyFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>({\n  strategy,\n  ...params\n}: AuthStrategyParams): AuthenticateAdmin<ConfigArg, Resources> {\n  const {api, logger, config} = params;\n\n  async function respondToBouncePageRequest(request: Request) {\n    const url = new URL(request.url);\n\n    if (url.pathname === config.auth.patchSessionTokenPath) {\n      logger.debug('Rendering bounce page', {\n        shop: getShopFromRequest(request),\n      });\n      throw renderAppBridge({config, logger, api}, request);\n    }\n  }\n\n  async function respondToExitIframeRequest(request: Request) {\n    const url = new URL(request.url);\n\n    if (url.pathname === config.auth.exitIframePath) {\n      const destination = url.searchParams.get('exitIframe')!;\n\n      logger.debug('Rendering exit iframe page', {\n        shop: getShopFromRequest(request),\n        destination,\n      });\n      throw renderAppBridge({config, logger, api}, request, {url: destination});\n    }\n  }\n\n  type AdminContextBase =\n    | EmbeddedAdminContext<ConfigArg, Resources>\n    | NonEmbeddedAdminContext<ConfigArg, Resources>;\n\n  function createContext(\n    request: Request,\n    session: Session,\n    authStrategy: AuthorizationStrategy,\n    sessionToken?: JwtPayload,\n  ): AdminContext<ConfigArg, Resources> {\n    let context: AdminContextBase = {\n      admin: createAdminApiContext<ConfigArg, Resources>(\n        session,\n        params,\n        authStrategy.handleClientError(request),\n      ),\n      billing: {\n        require: requireBillingFactory(params, request, session),\n        check: checkBillingFactory(params, request, session),\n        request: requestBillingFactory(params, request, session),\n        cancel: cancelBillingFactory(params, request, session),\n        createUsageRecord: createUsageRecordFactory(params, request, session),\n        updateUsageCappedAmount: updateUsageCappedAmountFactory(\n          params,\n          request,\n          session,\n        ),\n      },\n\n      session,\n      cors: ensureCORSHeadersFactory(params, request),\n    };\n\n    context = addEmbeddedFeatures(context, request, session, sessionToken);\n    context = addScopesFeatures(context);\n\n    return context as AdminContext<ConfigArg, Resources>;\n  }\n\n  function addEmbeddedFeatures(\n    context: AdminContextBase,\n    request: Request,\n    session: Session,\n    sessionToken?: JwtPayload,\n  ) {\n    if (config.isEmbeddedApp) {\n      return {\n        ...context,\n        sessionToken,\n        redirect: redirectFactory(params, request, session.shop),\n      };\n    }\n    return context;\n  }\n\n  function addScopesFeatures(context: AdminContextBase) {\n    return {\n      ...context,\n      scopes: scopesApiFactory(params, context.session, context.admin),\n    };\n  }\n\n  return async function authenticateAdmin(request: Request) {\n    try {\n      respondToBotRequest(params, request);\n      respondToOptionsRequest(params, request);\n      await respondToBouncePageRequest(request);\n      await respondToExitIframeRequest(request);\n      await strategy.respondToOAuthRequests(request);\n\n      // If this is a valid request, but it doesn't have a session token header, this is a document request. We need to\n      // ensure we're embedded if needed and we have the information needed to load the session.\n      if (!getSessionTokenHeader(request)) {\n        validateShopAndHostParams(params, request);\n        await ensureAppIsEmbeddedIfRequired(params, request);\n        await ensureSessionTokenSearchParamIfRequired(params, request);\n      }\n\n      logger.info('Authenticating admin request', {\n        shop: getShopFromRequest(request),\n      });\n\n      const {payload, shop, sessionId, sessionToken} =\n        await getSessionTokenContext(params, request);\n\n      logger.debug('Loading session from storage', {shop, sessionId});\n      const existingSession = sessionId\n        ? await config.sessionStorage!.loadSession(sessionId)\n        : undefined;\n\n      const session = await strategy.authenticate(request, {\n        session: existingSession,\n        sessionToken,\n        shop,\n      });\n\n      return createContext(request, session, strategy, payload);\n    } catch (errorOrResponse) {\n      if (errorOrResponse instanceof Response) {\n        logger.debug('Authenticate returned a response', {\n          shop: getShopFromRequest(request),\n        });\n        ensureCORSHeadersFactory(params, request)(errorOrResponse);\n      }\n\n      throw errorOrResponse;\n    }\n  };\n}\n\nasync function getSessionTokenContext(\n  params: BasicParams,\n  request: Request,\n): Promise<SessionTokenContext> {\n  const {api, config, logger} = params;\n\n  const headerSessionToken = getSessionTokenHeader(request);\n  const searchParamSessionToken = getSessionTokenFromUrlParam(request);\n  const sessionToken = (headerSessionToken || searchParamSessionToken)!;\n\n  logger.debug('Attempting to authenticate session token', {\n    shop: getShopFromRequest(request),\n    sessionToken: JSON.stringify({\n      header: headerSessionToken,\n      search: searchParamSessionToken,\n    }),\n  });\n\n  if (config.isEmbeddedApp) {\n    const payload = await validateSessionToken(params, request, sessionToken);\n    const dest = new URL(payload.dest);\n    const shop = dest.hostname;\n\n    logger.debug('Session token is valid - authenticated', {shop, payload});\n    const sessionId = config.useOnlineTokens\n      ? api.session.getJwtSessionId(shop, payload.sub)\n      : api.session.getOfflineId(shop);\n\n    return {shop, payload, sessionId, sessionToken};\n  }\n\n  const url = new URL(request.url);\n  const shop = url.searchParams.get('shop')!;\n\n  const sessionId = await api.session.getCurrentId({\n    isOnline: config.useOnlineTokens,\n    rawRequest: request,\n  });\n\n  return {shop, sessionId, payload: undefined, sessionToken};\n}\n", "import {HttpResponseError} from '@shopify/shopify-api';\n\nimport type {HandleAdminClientError} from '../../../clients/admin/types';\nimport {HandleClientErrorOptions} from '../strategies/types';\n\nexport function handleClientErrorFactory({\n  request,\n  onError,\n}: HandleClientErrorOptions): HandleAdminClientError {\n  return async function handleClientError({\n    error,\n    params,\n    session,\n  }): Promise<never> {\n    if (error instanceof HttpResponseError !== true) {\n      params.logger.debug(\n        `Got a response error from the API: ${error.message}`,\n        {shop: session.shop},\n      );\n      throw error;\n    }\n\n    params.logger.debug(\n      `Got an HTTP response error from the API: ${error.message}`,\n      {\n        shop: session.shop,\n        code: error.response.code,\n        statusText: error.response.statusText,\n        body: JSON.stringify(error.response.body),\n      },\n    );\n\n    if (onError) {\n      await onError({request, session, error});\n    }\n\n    // forward a minimal copy of the upstream HTTP response instead of an Error:\n    throw new Response(JSON.stringify(error.response.body), {\n      status: error.response.code,\n      headers: {\n        'Content-Type': error.response.headers!['Content-Type'] as string,\n      },\n    });\n  };\n}\n", "import {AppDistribution, BasicParams} from '../../types';\n\nexport async function createOrLoadOfflineSession(\n  shop: string,\n  {api, config, logger}: BasicParams,\n) {\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    logger.debug('Creating custom app session from configured access token', {\n      shop,\n    });\n    return api.session.customAppSession(shop);\n  } else {\n    logger.debug('Loading offline session from session storage', {shop});\n    const offlineSessionId = api.session.getOfflineId(shop);\n    const session = await config.sessionStorage!.loadSession(offlineSessionId);\n\n    return session;\n  }\n}\n", "import {\n  ShopifyRestResources,\n  WebhookValidationErrorReason,\n} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../config-types';\nimport type {BasicParams} from '../../types';\nimport {adminClientFactory} from '../../clients';\nimport {handleClientErrorFactory} from '../admin/helpers';\nimport {createOrLoadOfflineSession} from '../helpers';\n\nimport type {\n  AuthenticateWebhook,\n  WebhookContext,\n  WebhookContextWithoutSession,\n} from './types';\n\nexport function authenticateWebhookFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources,\n  Topics extends string,\n>(params: BasicParams): AuthenticateWebhook<ConfigArg, Resources, Topics> {\n  const {api, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<WebhookContext<ConfigArg, Resources, Topics>> {\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for a webhook. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n\n    const check = await api.webhooks.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!check.valid) {\n      if (check.reason === WebhookValidationErrorReason.InvalidHmac) {\n        logger.debug('Webhook HMAC validation failed', check);\n        throw new Response(undefined, {\n          status: 401,\n          statusText: 'Unauthorized',\n        });\n      } else {\n        logger.debug('Webhook validation failed', check);\n        throw new Response(undefined, {status: 400, statusText: 'Bad Request'});\n      }\n    }\n    const session = await createOrLoadOfflineSession(check.domain, params);\n    const webhookContext: WebhookContextWithoutSession<Topics> = {\n      apiVersion: check.apiVersion,\n      shop: check.domain,\n      topic: check.topic as Topics,\n      webhookId: check.webhookId,\n      payload: JSON.parse(rawBody),\n      subTopic: check.subTopic || undefined,\n      session: undefined,\n      admin: undefined,\n    };\n\n    if (!session) {\n      return webhookContext;\n    }\n\n    const admin = adminClientFactory<ConfigArg, Resources>({\n      params,\n      session,\n      handleClientError: handleClientErrorFactory({request}),\n    });\n\n    return {\n      ...webhookContext,\n      session,\n      admin,\n    };\n  };\n}\n", "import semver from 'semver';\nimport {FeatureDeprecatedError, Shopify} from '@shopify/shopify-api';\n\nimport {SHOPIFY_REMIX_LIBRARY_VERSION} from './version';\n\n// eslint-disable-next-line no-warning-comments\n// TODO This has been copied from shopify-app-express, it should be extracted into a shared package\n// https://github.com/orgs/Shopify/projects/6899/views/1?pane=issue&itemId=28358070\nexport function overrideLogger(logger: Shopify['logger']): Shopify['logger'] {\n  const baseContext = {package: 'shopify-app'};\n\n  const warningFunction: Shopify['logger']['warning'] = (\n    message,\n    context = {},\n  ) => logger.warning(message, {...baseContext, ...context});\n\n  function deprecated(warningFunction: Shopify['logger']['warning']) {\n    return function (version: string, message: string): Promise<void> {\n      if (semver.gte(SHOPIFY_REMIX_LIBRARY_VERSION, version)) {\n        throw new FeatureDeprecatedError(\n          `Feature was deprecated in version ${version}`,\n        );\n      }\n\n      return warningFunction(`[Deprecated | ${version}] ${message}`);\n    };\n  }\n\n  return {\n    ...logger,\n    log: (severity, message, context = {}) =>\n      logger.log(severity, message, {...baseContext, ...context}),\n    debug: (message, context = {}) =>\n      logger.debug(message, {...baseContext, ...context}),\n    info: (message, context = {}) =>\n      logger.info(message, {...baseContext, ...context}),\n    warning: warningFunction,\n    error: (message, context = {}) =>\n      logger.error(message, {...baseContext, ...context}),\n    deprecated: deprecated(warningFunction),\n  };\n}\n", "import {redirect} from '@remix-run/server-runtime';\n\nimport {BasicParams, LoginError, LoginErrorType} from '../../types';\n\nexport function loginFactory(params: BasicParams) {\n  const {api, config, logger} = params;\n\n  return async function login(request: Request): Promise<LoginError | never> {\n    const url = new URL(request.url);\n    const shopParam = url.searchParams.get('shop');\n\n    if (request.method === 'GET' && !shopParam) {\n      return {};\n    }\n\n    const shop: string | null =\n      shopParam || ((await request.formData()).get('shop') as string);\n\n    if (!shop) {\n      logger.debug('Missing shop parameter', {shop});\n      return {shop: LoginErrorType.MissingShop};\n    }\n\n    const shopWithoutProtocol = shop\n      .replace(/^https?:\\/\\//, '')\n      .replace(/\\/$/, '');\n    const shopWithDomain =\n      shop?.indexOf('.') === -1\n        ? `${shopWithoutProtocol}.myshopify.com`\n        : shopWithoutProtocol;\n    const sanitizedShop = api.utils.sanitizeShop(shopWithDomain);\n\n    if (!sanitizedShop) {\n      logger.debug('Invalid shop parameter', {shop});\n      return {shop: LoginErrorType.InvalidShop};\n    }\n\n    const authPath = `${config.appUrl}${config.auth.path}?shop=${sanitizedShop}`;\n\n    const adminPath = api.utils.legacyUrlToShopAdminUrl(sanitizedShop);\n    const installPath = `https://${adminPath}/oauth/install?client_id=${config.apiKey}`;\n\n    const shouldInstall =\n      config.isEmbeddedApp && config.future.unstable_newEmbeddedAuthStrategy;\n    const redirectUrl = shouldInstall ? installPath : authPath;\n\n    logger.info(`Redirecting login request to ${redirectUrl}`, {\n      shop: sanitizedShop,\n    });\n\n    throw redirect(redirectUrl);\n  };\n}\n", "import {ShopifyError} from '@shopify/shopify-api';\n\nexport class SessionNotFoundError extends ShopifyError {}\n", "import {ShopifyRestResources} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../config-types';\nimport {createOrLoadOfflineSession} from '../../authenticate/helpers/create-or-load-offline-session';\nimport {SessionNotFoundError} from '../../errors';\nimport {BasicParams} from '../../types';\nimport {adminClientFactory} from '../../clients/admin';\n\nimport {UnauthenticatedAdminContext} from './types';\n\nexport function unauthenticatedAdminContextFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources,\n>(params: BasicParams) {\n  return async (\n    shop: string,\n  ): Promise<UnauthenticatedAdminContext<ConfigArg, Resources>> => {\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      throw new SessionNotFoundError(\n        `Could not find a session for shop ${shop} when creating unauthenticated admin context`,\n      );\n    }\n\n    return {\n      session,\n      admin: adminClientFactory<ConfigArg, Resources>({params, session}),\n    };\n  };\n}\n", "import {BasicParams} from '../../../types';\nimport {\n  respondToBotRequest,\n  respondToOptionsRequest,\n  getSessionTokenHeader,\n  validateSessionToken,\n  ensureCORSHeadersFactory,\n  getShopFromRequest,\n} from '../../helpers';\n\nimport {AuthenticateExtension, ExtensionContext} from './types';\n\nexport function authenticateExtensionFactory(\n  params: BasicParams,\n  requestType: string,\n): AuthenticateExtension {\n  return async function authenticateExtension(\n    request,\n    options = {},\n  ): Promise<ExtensionContext> {\n    const {logger} = params;\n\n    const corsHeaders = options.corsHeaders ?? [];\n\n    respondToBotRequest(params, request);\n    respondToOptionsRequest(params, request, corsHeaders);\n\n    const sessionTokenHeader = getSessionTokenHeader(request);\n\n    logger.info(`Authenticating ${requestType} request`, {\n      shop: getShopFromRequest(request),\n    });\n\n    if (!sessionTokenHeader) {\n      logger.debug('Request did not contain a session token', {\n        shop: getShopFromRequest(request),\n      });\n      throw new Response(undefined, {\n        status: 401,\n        statusText: 'Unauthorized',\n      });\n    }\n\n    return {\n      sessionToken: await validateSessionToken(\n        params,\n        request,\n        sessionTokenHeader,\n        {checkAudience: false, retryRequest: false},\n      ),\n      cors: ensureCORSHeadersFactory(params, request, corsHeaders),\n    };\n  };\n}\n", "import type {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport type {AuthenticateCheckout} from './types';\n\nexport function authenticateCheckoutFactory(\n  params: BasicParams,\n): AuthenticateCheckout {\n  return authenticateExtensionFactory(\n    params,\n    'checkout',\n  ) as AuthenticateCheckout;\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../types';\n\nimport type {StorefrontContext} from '.';\n\nexport function storefrontClientFactory({\n  params,\n  session,\n}: {\n  params: BasicParams;\n  session: Session;\n}): StorefrontContext {\n  const {api} = params;\n\n  return {\n    graphql: async (query, options = {}) => {\n      const client = new api.clients.Storefront({\n        session,\n        apiVersion: options.apiVersion,\n      });\n\n      const apiResponse = await client.request(query, {\n        variables: options?.variables,\n        retries: options?.tries ? options.tries - 1 : 0,\n        headers: options?.headers,\n      });\n\n      return new Response(JSON.stringify(apiResponse));\n    },\n  };\n}\n", "import {ShopifyRestResources} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {adminClientFactory, storefrontClientFactory} from '../../../clients';\nimport {BasicParams} from '../../../types';\n\nimport {\n  AppProxyContext,\n  AppProxyContextWithSession,\n  AuthenticateAppProxy,\n  LiquidResponseFunction,\n} from './types';\n\nexport function authenticateAppProxyFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources,\n>(params: BasicParams): AuthenticateAppProxy<ConfigArg, Resources> {\n  const {api, config, logger} = params;\n\n  return async function authenticate(\n    request,\n  ): Promise<\n    AppProxyContext | AppProxyContextWithSession<ConfigArg, Resources>\n  > {\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop')!;\n    logger.info('Authenticating app proxy request', {shop});\n\n    if (!(await validateAppProxyHmac(params, url))) {\n      logger.info('App proxy request has invalid signature', {shop});\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const sessionId = api.session.getOfflineId(shop);\n    const session = await config.sessionStorage!.loadSession(sessionId);\n\n    if (!session) {\n      logger.debug('Could not find offline session, returning empty context', {\n        shop,\n        ...Object.fromEntries(url.searchParams.entries()),\n      });\n\n      const context: AppProxyContext = {\n        liquid,\n        session: undefined,\n        admin: undefined,\n        storefront: undefined,\n      };\n\n      return context;\n    }\n\n    const context: AppProxyContextWithSession<ConfigArg, Resources> = {\n      liquid,\n      session,\n      admin: adminClientFactory<ConfigArg, Resources>({params, session}),\n      storefront: storefrontClientFactory({params, session}),\n    };\n\n    return context;\n  };\n}\n\nconst liquid: LiquidResponseFunction = (body, initAndOptions) => {\n  const processedBody = processLiquidBody(body);\n\n  if (typeof initAndOptions !== 'object') {\n    return new Response(processedBody, {\n      status: initAndOptions || 200,\n      headers: {\n        'Content-Type': 'application/liquid',\n      },\n    });\n  }\n\n  const {layout, ...responseInit} = initAndOptions || {};\n  const responseBody =\n    layout === false ? `{% layout none %} ${processedBody}` : processedBody;\n\n  const headers = new Headers(responseInit.headers);\n  headers.set('Content-Type', 'application/liquid');\n\n  return new Response(responseBody, {\n    ...responseInit,\n    headers,\n  });\n};\n\nasync function validateAppProxyHmac(\n  params: BasicParams,\n  url: URL,\n): Promise<boolean> {\n  const {api, logger} = params;\n\n  try {\n    let searchParams = new URLSearchParams(url.search);\n    if (!searchParams.get('index')) {\n      searchParams.delete('index');\n    }\n\n    let isValid = await api.utils.validateHmac(\n      Object.fromEntries(searchParams.entries()),\n      {signator: 'appProxy'},\n    );\n\n    if (!isValid) {\n      const cleanPath = url.pathname\n        .replace(/^\\//, '')\n        .replace(/\\/$/, '')\n        .replaceAll('/', '.');\n      const data = `routes%2F${cleanPath}`;\n\n      searchParams = new URLSearchParams(\n        `?_data=${data}&${searchParams.toString().replace(/^\\?/, '')}`,\n      );\n\n      isValid = await api.utils.validateHmac(\n        Object.fromEntries(searchParams.entries()),\n        {signator: 'appProxy'},\n      );\n\n      if (!isValid) {\n        const searchParams = new URLSearchParams(\n          `?_data=${data}._index&${url.search.replace(/^\\?/, '')}`,\n        );\n\n        isValid = await api.utils.validateHmac(\n          Object.fromEntries(searchParams.entries()),\n          {signator: 'appProxy'},\n        );\n      }\n    }\n\n    return isValid;\n  } catch (error) {\n    const shop = url.searchParams.get('shop')!;\n    logger.info(error.message, {shop});\n    throw new Response(undefined, {status: 400, statusText: 'Bad Request'});\n  }\n}\n\nfunction processLiquidBody(body: string) {\n  return (\n    body\n      // Add trailing slashes to relative form action URLs\n      .replaceAll(\n        /<(form[^>]+)action=\"(\\/[^\"?]+)(\\?[^\"]+)?\">/g,\n        '<$1action=\"$2/$3\">',\n      )\n      // Add trailing slashes to relative link href URLs\n      .replaceAll(/<(a[^>]+)href=\"(\\/[^\"?]+)(\\?[^\"]+)?\">/g, '<$1href=\"$2/$3\">')\n  );\n}\n", "import {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport {AuthenticateCustomerAccount} from './types';\n\nexport function authenticateCustomerAccountFactory(\n  params: BasicParams,\n): AuthenticateCustomerAccount {\n  return authenticateExtensionFactory(\n    params,\n    'customer account',\n  ) as AuthenticateCustomerAccount;\n}\n", "import {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport type {AuthenticatePOS} from './types';\n\nexport function authenticatePOSFactory(params: BasicParams): AuthenticatePOS {\n  return authenticateExtensionFactory(params, 'pos') as AuthenticatePOS;\n}\n", "import {ShopifyRestResources} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../config-types';\nimport {BasicParams} from '../../types';\n\nimport {authenticateCheckoutFactory} from './checkout/authenticate';\nimport {authenticateAppProxyFactory} from './appProxy/authenticate';\nimport {authenticateCustomerAccountFactory} from './customer-account/authenticate';\nimport {AuthenticatePublic} from './types';\nimport {authenticatePOSFactory} from './pos/authenticate';\n\nexport function authenticatePublicFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources,\n>(params: BasicParams) {\n  const authenticateCheckout = authenticateCheckoutFactory(params);\n  const authenticateAppProxy = authenticateAppProxyFactory<\n    ConfigArg,\n    Resources\n  >(params);\n  const authenticateCustomerAccount =\n    authenticateCustomerAccountFactory(params);\n  const authenticatePOS = authenticatePOSFactory(params);\n\n  const context: AuthenticatePublic<ConfigArg> = {\n    checkout: authenticateCheckout,\n    appProxy: authenticateAppProxy,\n    customerAccount: authenticateCustomerAccount,\n    pos: authenticatePOS,\n  };\n\n  return context;\n}\n", "import {createOrLoadOfflineSession} from '../../authenticate/helpers/create-or-load-offline-session';\nimport {SessionNotFoundError} from '../../errors';\nimport {BasicParams} from '../../types';\nimport {storefrontClientFactory} from '../../clients/storefront';\n\nimport {\n  UnauthenticatedStorefrontContext,\n  GetUnauthenticatedStorefrontContext,\n} from './types';\n\nexport function unauthenticatedStorefrontContextFactory(\n  params: BasicParams,\n): GetUnauthenticatedStorefrontContext {\n  return async (shop: string): Promise<UnauthenticatedStorefrontContext> => {\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      throw new SessionNotFoundError(\n        `Could not find a session for shop ${shop} when creating unauthenticated storefront context`,\n      );\n    }\n\n    return {\n      session,\n      storefront: storefrontClientFactory({params, session}),\n    };\n  };\n}\n", "import {Session, ShopifyRestResources} from '@shopify/shopify-api';\n\nimport type {AppConfigArg} from '../../../config-types';\nimport {AdminApiContextWithRest} from '../../../clients';\nimport type {BasicParams} from '../../../types';\nimport {AuthorizationStrategy} from '../strategies/types';\n\nimport {createAdminApiContext} from './create-admin-api-context';\n\nexport async function triggerAfterAuthHook<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>(\n  params: BasicParams,\n  session: Session,\n  request: Request,\n  authStrategy: AuthorizationStrategy,\n) {\n  const {config, logger} = params;\n  if (config.hooks.afterAuth) {\n    logger.info('Running afterAuth hook', {shop: session.shop});\n\n    const admin = createAdminApiContext<ConfigArg, Resources>(\n      session,\n      params,\n      authStrategy.handleClientError(request),\n    ) as AdminApiContextWithRest<Resources>;\n\n    await config.hooks.afterAuth({\n      session,\n      admin,\n    });\n  }\n}\n", "import {\n  CookieNotFound,\n  GraphqlQueryError,\n  HttpResponseError,\n  InvalidHmacError,\n  InvalidOAuthError,\n  Session,\n  Shopify,\n  ShopifyRestResources,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  beginAuth,\n  handleClientErrorFactory,\n  redirectToAuthPage,\n  redirectToShopifyOrAppRoot,\n  redirectWithExitIframe,\n  triggerAfterAuthHook,\n  validateShopAndHostParams,\n} from '../helpers';\nimport {AppConfig, AppConfigArg} from '../../../config-types';\nimport {getSessionTokenHeader} from '../../helpers';\nimport {HandleAdminClientError} from '../../../clients';\nimport type {\n  ApiConfigWithFutureFlags,\n  ApiFutureFlags,\n} from '../../../future/flags';\n\nimport {AuthorizationStrategy, SessionContext, OnErrorOptions} from './types';\n\nexport class AuthCodeFlowStrategy<\n  Config extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n> implements AuthorizationStrategy\n{\n  protected api: Shopify<\n    ApiConfigWithFutureFlags<Config['future']>,\n    ShopifyRestResources,\n    ApiFutureFlags<Config['future']>\n  >;\n\n  protected config: AppConfig;\n  protected logger: Shopify['logger'];\n\n  public constructor({api, config, logger}: BasicParams) {\n    this.api = api;\n    this.config = config;\n    this.logger = logger;\n  }\n\n  public async respondToOAuthRequests(request: Request): Promise<void | never> {\n    const {api, config} = this;\n\n    const url = new URL(request.url);\n    const isAuthRequest = url.pathname === config.auth.path;\n    const isAuthCallbackRequest = url.pathname === config.auth.callbackPath;\n\n    if (isAuthRequest || isAuthCallbackRequest) {\n      const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!);\n      if (!shop) throw new Response('Shop param is invalid', {status: 400});\n\n      if (isAuthRequest) {\n        throw await this.handleAuthBeginRequest(request, shop);\n      } else {\n        throw await this.handleAuthCallbackRequest(request, shop);\n      }\n    }\n\n    if (!getSessionTokenHeader(request)) {\n      // This is a document request that doesn't contain a session token. We check if the app is installed.\n      // If the app isn't installed, we initiate the OAuth auth code flow.\n      // Requests with a header can only happen after the app is installed.\n      await this.ensureInstalledOnShop(request);\n    }\n  }\n\n  public async authenticate(\n    request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session | never> {\n    const {api, config, logger} = this;\n\n    const {shop, session} = sessionContext;\n\n    if (!session) {\n      logger.debug('No session found, redirecting to OAuth', {shop});\n      await redirectToAuthPage({config, logger, api}, request, shop);\n    } else if (!session.isActive(config.scopes)) {\n      logger.debug(\n        'Found a session, but it has expired, redirecting to OAuth',\n        {shop},\n      );\n      await redirectToAuthPage({config, logger, api}, request, shop);\n    }\n\n    logger.debug('Found a valid session', {shop});\n\n    return session!;\n  }\n\n  public handleClientError(request: Request): HandleAdminClientError {\n    const {api, config, logger} = this;\n    return handleClientErrorFactory({\n      request,\n      onError: async ({session, error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          throw await redirectToAuthPage(\n            {api, config, logger},\n            request,\n            session.shop,\n          );\n        }\n      },\n    });\n  }\n\n  private async ensureInstalledOnShop(request: Request) {\n    const {api, config, logger} = this;\n\n    validateShopAndHostParams({api, config, logger}, request);\n\n    const url = new URL(request.url);\n    let shop = url.searchParams.get('shop');\n\n    // Ensure app is installed\n    logger.debug('Ensuring app is installed on shop', {shop});\n\n    if (!(await this.hasValidOfflineId(request))) {\n      logger.info(\"Could not find a shop, can't authenticate request\");\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const offlineSession = await this.getOfflineSession(request);\n    const isEmbedded = url.searchParams.get('embedded') === '1';\n\n    if (!offlineSession) {\n      logger.info(\"Shop hasn't installed app yet, redirecting to OAuth\", {\n        shop,\n      });\n      if (isEmbedded) {\n        redirectWithExitIframe({api, config, logger}, request, shop!);\n      } else {\n        throw await beginAuth({api, config, logger}, request, false, shop!);\n      }\n    }\n\n    shop = shop || offlineSession.shop;\n\n    if (config.isEmbeddedApp && !isEmbedded) {\n      try {\n        logger.debug('Ensuring offline session is valid before embedding', {\n          shop,\n        });\n        await this.testSession(offlineSession);\n\n        logger.debug('Offline session is still valid, embedding app', {shop});\n      } catch (error) {\n        await this.handleInvalidOfflineSession(error, request, shop);\n      }\n    }\n  }\n\n  private async handleAuthBeginRequest(\n    request: Request,\n    shop: string,\n  ): Promise<never> {\n    const {api, config, logger} = this;\n\n    logger.info('Handling OAuth begin request', {shop});\n\n    // If we're loading from an iframe, we need to break out of it\n    if (\n      config.isEmbeddedApp &&\n      request.headers.get('Sec-Fetch-Dest') === 'iframe'\n    ) {\n      logger.debug('Auth request in iframe detected, exiting iframe', {shop});\n      throw redirectWithExitIframe({api, config, logger}, request, shop);\n    } else {\n      throw await beginAuth({api, config, logger}, request, false, shop);\n    }\n  }\n\n  private async handleAuthCallbackRequest(\n    request: Request,\n    shop: string,\n  ): Promise<never> {\n    const {api, config, logger} = this;\n\n    logger.info('Handling OAuth callback request', {shop});\n\n    try {\n      const {session, headers: responseHeaders} = await api.auth.callback({\n        rawRequest: request,\n      });\n\n      await config.sessionStorage!.storeSession(session);\n\n      if (config.useOnlineTokens && !session.isOnline) {\n        logger.info('Requesting online access token for offline session', {\n          shop,\n        });\n        await beginAuth({api, config, logger}, request, true, shop);\n      }\n\n      logger.debug('Request is valid, loaded session from OAuth callback', {\n        shop: session.shop,\n        isOnline: session.isOnline,\n      });\n\n      await triggerAfterAuthHook<Config, Resources>(\n        {api, config, logger},\n        session,\n        request,\n        this,\n      );\n\n      throw await redirectToShopifyOrAppRoot(\n        request,\n        {api, config, logger},\n        responseHeaders,\n      );\n    } catch (error) {\n      if (error instanceof Response) throw error;\n\n      throw await this.oauthCallbackError(error, request, shop);\n    }\n  }\n\n  private async getOfflineSession(\n    request: Request,\n  ): Promise<Session | undefined> {\n    const offlineId = await this.getOfflineSessionId(request);\n    return this.config.sessionStorage!.loadSession(offlineId!);\n  }\n\n  private async hasValidOfflineId(request: Request) {\n    return Boolean(await this.getOfflineSessionId(request));\n  }\n\n  private async getOfflineSessionId(\n    request: Request,\n  ): Promise<string | undefined> {\n    const {api} = this;\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop');\n\n    return shop\n      ? api.session.getOfflineId(shop)\n      : api.session.getCurrentId({isOnline: false, rawRequest: request});\n  }\n\n  private async testSession(session: Session): Promise<void> {\n    const {api} = this;\n\n    const client = new api.clients.Graphql({\n      session,\n    });\n\n    await client.request(`#graphql\n      query shopifyAppShopName {\n        shop {\n          name\n        }\n      }\n    `);\n  }\n\n  private async oauthCallbackError(\n    error: Error,\n    request: Request,\n    shop: string,\n  ) {\n    const {logger} = this;\n    logger.error('Error during OAuth callback', {shop, error: error.message});\n\n    if (error instanceof CookieNotFound) {\n      return this.handleAuthBeginRequest(request, shop);\n    }\n\n    if (\n      error instanceof InvalidHmacError ||\n      error instanceof InvalidOAuthError\n    ) {\n      return new Response(undefined, {\n        status: 400,\n        statusText: 'Invalid OAuth Request',\n      });\n    }\n\n    return new Response(undefined, {\n      status: 500,\n      statusText: 'Internal Server Error',\n    });\n  }\n\n  private async handleInvalidOfflineSession(\n    error: Error,\n    request: Request,\n    shop: string,\n  ) {\n    const {api, logger, config} = this;\n    if (error instanceof HttpResponseError) {\n      if (error.response.code === 401) {\n        logger.info('Shop session is no longer valid, redirecting to OAuth', {\n          shop,\n        });\n        throw await beginAuth({api, config, logger}, request, false, shop);\n      } else {\n        const message = JSON.stringify(error.response.body, null, 2);\n        logger.error(`Unexpected error during session validation: ${message}`, {\n          shop,\n        });\n\n        throw new Response(undefined, {\n          status: error.response.code,\n          statusText: error.response.statusText,\n        });\n      }\n    } else if (error instanceof GraphqlQueryError) {\n      const context: Record<string, string> = {shop};\n      if (error.response) {\n        context.response = JSON.stringify(error.body);\n      }\n\n      logger.error(\n        `Unexpected error during session validation: ${error.message}`,\n        context,\n      );\n\n      throw new Response(undefined, {\n        status: 500,\n        statusText: 'Internal Server Error',\n      });\n    }\n  }\n}\n", "import {\n  HttpResponseError,\n  InvalidJwtError,\n  RequestedTokenType,\n  Session,\n  Shopify,\n  ShopifyRestResources,\n} from '@shopify/shopify-api';\n\nimport {AppConfig, AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {\n  respondToInvalidSessionToken,\n  invalidateAccessToken,\n  getShopFromRequest,\n} from '../../helpers';\nimport {handleClientErrorFactory, triggerAfterAuthHook} from '../helpers';\nimport {HandleAdminClientError} from '../../../clients';\nimport type {\n  ApiConfigWithFutureFlags,\n  ApiFutureFlags,\n} from '../../../future/flags';\n\nimport {AuthorizationStrategy, SessionContext, OnErrorOptions} from './types';\n\nexport class TokenExchangeStrategy<Config extends AppConfigArg>\n  implements AuthorizationStrategy\n{\n  protected api: Shopify<\n    ApiConfigWithFutureFlags<Config['future']>,\n    ShopifyRestResources,\n    ApiFutureFlags<Config['future']>\n  >;\n\n  protected config: AppConfig;\n  protected logger: Shopify['logger'];\n\n  public constructor({api, config, logger}: BasicParams<Config['future']>) {\n    this.api = api;\n    this.config = config;\n    this.logger = logger;\n  }\n\n  public async respondToOAuthRequests(_request: Request): Promise<void> {}\n\n  public async authenticate(\n    request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session> {\n    const {api, config, logger} = this;\n    const {shop, session, sessionToken} = sessionContext;\n\n    if (!sessionToken) throw new InvalidJwtError();\n\n    if (!session || !session.isActive(undefined)) {\n      logger.info('No valid session found', {shop});\n      logger.info('Requesting offline access token', {shop});\n      const {session: offlineSession} = await this.exchangeToken({\n        request,\n        sessionToken,\n        shop,\n        requestedTokenType: RequestedTokenType.OfflineAccessToken,\n      });\n\n      await config.sessionStorage!.storeSession(offlineSession);\n\n      let newSession = offlineSession;\n\n      if (config.useOnlineTokens) {\n        logger.info('Requesting online access token', {shop});\n        const {session: onlineSession} = await this.exchangeToken({\n          request,\n          sessionToken,\n          shop,\n          requestedTokenType: RequestedTokenType.OnlineAccessToken,\n        });\n\n        await config.sessionStorage!.storeSession(onlineSession);\n        newSession = onlineSession;\n      }\n\n      logger.debug('Request is valid, loaded session from session token', {\n        shop: newSession.shop,\n        isOnline: newSession.isOnline,\n      });\n\n      try {\n        await this.handleAfterAuthHook(\n          {api, config, logger},\n          newSession,\n          request,\n          sessionToken,\n        );\n      } catch (errorOrResponse) {\n        if (errorOrResponse instanceof Response) {\n          throw errorOrResponse;\n        }\n\n        throw new Response(undefined, {\n          status: 500,\n          statusText: 'Internal Server Error',\n        });\n      }\n\n      return newSession;\n    }\n\n    return session!;\n  }\n\n  public handleClientError(request: Request): HandleAdminClientError {\n    const {api, config, logger} = this;\n    return handleClientErrorFactory({\n      request,\n      onError: async ({session, error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          logger.debug('Responding to invalid access token', {\n            shop: getShopFromRequest(request),\n          });\n          await invalidateAccessToken({config, api, logger}, session);\n\n          respondToInvalidSessionToken({\n            params: {config, api, logger},\n            request,\n          });\n        }\n      },\n    });\n  }\n\n  private async exchangeToken({\n    request,\n    shop,\n    sessionToken,\n    requestedTokenType,\n  }: {\n    request: Request;\n    shop: string;\n    sessionToken: string;\n    requestedTokenType: RequestedTokenType;\n  }): Promise<{session: Session}> {\n    const {api, config, logger} = this;\n\n    try {\n      return await api.auth.tokenExchange({\n        sessionToken,\n        shop,\n        requestedTokenType,\n      });\n    } catch (error) {\n      if (\n        error instanceof InvalidJwtError ||\n        (error instanceof HttpResponseError &&\n          error.response.code === 400 &&\n          error.response.body?.error === 'invalid_subject_token')\n      ) {\n        throw respondToInvalidSessionToken({\n          params: {api, config, logger},\n          request,\n          retryRequest: true,\n        });\n      }\n\n      throw new Response(undefined, {\n        status: 500,\n        statusText: 'Internal Server Error',\n      });\n    }\n  }\n\n  private async handleAfterAuthHook(\n    params: BasicParams,\n    session: Session,\n    request: Request,\n    sessionToken: string,\n  ) {\n    const {config} = params;\n    await config.idempotentPromiseHandler.handlePromise({\n      promiseFunction: () => {\n        return triggerAfterAuthHook(params, session, request, this);\n      },\n      identifier: sessionToken,\n    });\n  }\n}\n", "import {\n  Session,\n  Shopify,\n  ShopifyError,\n  ShopifyRestResources,\n} from '@shopify/shopify-api';\n\nimport {AppConfig, AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {ApiConfigWithFutureFlags, ApiFutureFlags} from '../../../future/flags';\nimport {HandleAdminClientError} from '../../../clients';\nimport {handleClientErrorFactory} from '../helpers';\nimport {getShopFromRequest} from '../../helpers';\n\nimport {AuthorizationStrategy, OnErrorOptions, SessionContext} from './types';\n\nexport class MerchantCustomAuth<Config extends AppConfigArg>\n  implements AuthorizationStrategy\n{\n  protected api: Shopify<\n    ApiConfigWithFutureFlags<Config['future']>,\n    ShopifyRestResources,\n    ApiFutureFlags<Config['future']>\n  >;\n\n  protected config: AppConfig;\n  protected logger: Shopify['logger'];\n\n  public constructor({api, config, logger}: BasicParams<Config['future']>) {\n    this.api = api;\n    this.config = config;\n    this.logger = logger;\n  }\n\n  public async respondToOAuthRequests(request: Request): Promise<void> {\n    this.logger.debug('Skipping OAuth request for merchant custom app', {\n      shop: getShopFromRequest(request),\n    });\n  }\n\n  public async authenticate(\n    _request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session | never> {\n    const {shop} = sessionContext;\n\n    this.logger.debug(\n      'Building session from configured access token for merchant custom app',\n      {shop},\n    );\n    const session = this.api.session.customAppSession(shop);\n\n    return session;\n  }\n\n  public handleClientError(request: Request): HandleAdminClientError {\n    return handleClientErrorFactory({\n      request,\n      onError: async ({error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          this.logger.info(\n            'Request failed with 401. Review your API credentials or generate new tokens. https://shopify.dev/docs/apps/build/authentication-authorization/access-token-types/generate-app-access-tokens-admin#rotating-api-credentials-for-admin-created-apps ',\n          );\n          throw new ShopifyError(\n            'Unauthorized: Access token has been revoked.',\n          );\n        }\n      },\n    });\n  }\n}\n", "export interface IdempotentHandlePromiseParams {\n  promiseFunction: () => Promise<any>;\n  identifier: string;\n}\n\nconst IDENTIFIER_TTL_MS = 60000;\n\nexport class IdempotentPromiseHandler {\n  protected identifiers: Map<string, number>;\n\n  constructor() {\n    this.identifiers = new Map<string, number>();\n  }\n\n  async handlePromise({\n    promiseFunction,\n    identifier,\n  }: IdempotentHandlePromiseParams): Promise<any> {\n    try {\n      if (this.isPromiseRunnable(identifier)) {\n        await promiseFunction();\n      }\n    } finally {\n      this.clearStaleIdentifiers();\n    }\n\n    return Promise.resolve();\n  }\n\n  private isPromiseRunnable(identifier: string) {\n    if (!this.identifiers.has(identifier)) {\n      this.identifiers.set(identifier, Date.now());\n      return true;\n    }\n    return false;\n  }\n\n  private async clearStaleIdentifiers() {\n    this.identifiers.forEach((date, identifier, map) => {\n      if (Date.now() - date > IDENTIFIER_TTL_MS) {\n        map.delete(identifier);\n      }\n    });\n  }\n}\n", "import {ShopifyRestResources} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../config-types';\nimport {adminClientFactory} from '../../clients/admin';\nimport {BasicParams} from '../../types';\n\nimport type {AuthenticateFlow, FlowContext} from './types';\n\nexport function authenticateFlowFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>(params: BasicParams): AuthenticateFlow<ConfigArg, Resources> {\n  const {api, config, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<FlowContext<ConfigArg, Resources>> {\n    logger.info('Authenticating flow request');\n\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for flow. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n    const result = await api.flow.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!result.valid) {\n      logger.error('Received an invalid flow request', {reason: result.reason});\n\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const payload = JSON.parse(rawBody);\n\n    logger.debug('Flow request is valid, looking for an offline session', {\n      shop: payload.shopify_domain,\n    });\n\n    const sessionId = api.session.getOfflineId(payload.shopify_domain);\n    const session = await config.sessionStorage!.loadSession(sessionId);\n\n    if (!session) {\n      logger.info('Flow request could not find session', {\n        shop: payload.shopify_domain,\n      });\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    logger.debug('Found a session for the flow request', {shop: session.shop});\n\n    return {\n      session,\n      payload,\n      admin: adminClientFactory<ConfigArg, Resources>({params, session}),\n    };\n  };\n}\n", "import {ShopifyRestResources, ShopifyHeader} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../config-types';\nimport {adminClientFactory} from '../../clients/admin';\nimport {BasicParams} from '../../types';\nimport {createOrLoadOfflineSession} from '../helpers';\n\nimport type {\n  AuthenticateFulfillmentService,\n  FulfillmentServiceContext,\n} from './types';\n\nexport function authenticateFulfillmentServiceFactory<\n  ConfigArg extends AppConfigArg,\n  Resources extends ShopifyRestResources = ShopifyRestResources,\n>(params: BasicParams): AuthenticateFulfillmentService<ConfigArg, Resources> {\n  const {api, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<FulfillmentServiceContext<ConfigArg, Resources>> {\n    logger.info('Authenticating fulfillment service request');\n\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for fulfillment service. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n    const result = await api.fulfillmentService.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!result.valid) {\n      logger.error('Received an invalid fulfillment service request', {\n        reason: result.reason,\n      });\n\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const payload = JSON.parse(rawBody);\n    const shop = request.headers.get(ShopifyHeader.Domain) || '';\n\n    logger.debug(\n      'Fulfillment service request is valid, looking for an offline session',\n      {\n        shop,\n      },\n    );\n\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      logger.info('Fulfillment service request could not find session', {\n        shop,\n      });\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    logger.debug('Found a session for the fulfillment service request', {\n      shop,\n    });\n\n    return {\n      session,\n      payload,\n      admin: adminClientFactory<ConfigArg, Resources>({params, session}),\n    };\n  };\n}\n", "import type {\n  ConfigParams,\n  Shopify,\n  ShopifyRestResources,\n} from '@shopify/shopify-api';\n\nimport {AppConfig} from '../config-types';\n\n// When adding new flags, you should also add them to the `TEST_FUTURE_FLAGS` object in `test-config.ts` to ensure that\n// it doesn't cause regressions.\nexport interface FutureFlags {\n  /**\n   * When enabled, embedded apps will fetch access tokens via [token exchange](https://shopify.dev/docs/apps/auth/get-access-tokens/token-exchange).\n   * This assumes the app has scopes declared for [Shopify managing installation](https://shopify.dev/docs/apps/auth/installation#shopify-managed-installation).\n   *\n   * Learn more about this [new embedded app auth strategy](https://shopify.dev/docs/api/shopify-app-remix#embedded-auth-strategy).\n   *\n   * @default false\n   */\n  unstable_newEmbeddedAuthStrategy?: boolean;\n\n  /**\n   * When enabled, methods for interacting with the admin REST API will not be returned.\n   *\n   * This affects:\n   *\n   * * `authenticate.admin(request)`\n   * * `authenticate.webhook(request)`\n   * * `authenticate.flow(request)`\n   * * `authenticate.appProxy(request)`\n   * * `authenticate.fulfillmentService(request)`\n   * * `unauthenticated.admin(shop)`\n   *\n   * In a future release we will remove REST from the package completely.\n   *\n   * Please see: [https://www.shopify.com/ca/partners/blog/all-in-on-graphql](https://www.shopify.com/ca/partners/blog/all-in-on-graphql)\n   *\n   * @default false\n   */\n  removeRest?: boolean;\n}\n\n// When adding new flags, use this format:\n// apiFutureFlag: Future extends FutureFlags ? Future['remixFutureFlag'] : false;\nexport interface ApiFutureFlags<_Future extends FutureFlagOptions> {\n  // We're currently hardcoding this flag to true in our settings, so we should propagate it here\n  lineItemBilling: true;\n  unstable_managedPricingSupport: true;\n}\n\nexport type ApiConfigWithFutureFlags<Future extends FutureFlagOptions> =\n  ConfigParams<ShopifyRestResources, ApiFutureFlags<Future>>;\n\nexport type FutureFlagOptions = FutureFlags | undefined;\n\nexport type FeatureEnabled<\n  Future extends FutureFlagOptions,\n  Flag extends keyof FutureFlags,\n> = Future extends FutureFlags\n  ? Future[Flag] extends true\n    ? true\n    : false\n  : false;\n\nexport function logDisabledFutureFlags(\n  config: AppConfig,\n  logger: Shopify['logger'],\n) {\n  const logFlag = (flag: string, message: string) =>\n    logger.info(`Future flag ${flag} is disabled.\\n\\n  ${message}\\n`);\n\n  if (!config.future.unstable_newEmbeddedAuthStrategy) {\n    logFlag(\n      'unstable_newEmbeddedAuthStrategy',\n      'Enable this to use OAuth token exchange instead of auth code to generate API access tokens.' +\n        '\\n  Your app must be using Shopify managed install: https://shopify.dev/docs/apps/auth/installation',\n    );\n  }\n}\n", "import '@shopify/shopify-api/adapters/web-api';\nimport {\n  ConfigInterface as ApiConfig,\n  LATEST_API_VERSION,\n  ShopifyError,\n  ShopifyRestResources,\n  shopifyApi,\n} from '@shopify/shopify-api';\nimport {SessionStorage} from '@shopify/shopify-app-session-storage';\n\nimport {type AppConfig, type AppConfigArg} from './config-types';\nimport {\n  AppDistribution,\n  type BasicParams,\n  type ShopifyApp,\n  type ShopifyAppBase,\n  type AdminApp,\n  type SingleMerchantApp,\n  type AppStoreApp,\n} from './types';\nimport {SHOPIFY_REMIX_LIBRARY_VERSION} from './version';\nimport {registerWebhooksFactory} from './authenticate/webhooks';\nimport {authStrategyFactory} from './authenticate/admin/authenticate';\nimport {authenticateWebhookFactory} from './authenticate/webhooks/authenticate';\nimport {overrideLogger} from './override-logger';\nimport {addDocumentResponseHeadersFactory} from './authenticate/helpers';\nimport {loginFactory} from './authenticate/login/login';\nimport {unauthenticatedAdminContextFactory} from './unauthenticated/admin';\nimport {authenticatePublicFactory} from './authenticate/public';\nimport {unauthenticatedStorefrontContextFactory} from './unauthenticated/storefront';\nimport {AuthCodeFlowStrategy} from './authenticate/admin/strategies/auth-code-flow';\nimport {TokenExchangeStrategy} from './authenticate/admin/strategies/token-exchange';\nimport {MerchantCustomAuth} from './authenticate/admin/strategies/merchant-custom-app';\nimport {IdempotentPromiseHandler} from './authenticate/helpers/idempotent-promise-handler';\nimport {authenticateFlowFactory} from './authenticate/flow/authenticate';\nimport {authenticateFulfillmentServiceFactory} from './authenticate/fulfillment-service/authenticate';\nimport {FutureFlagOptions, logDisabledFutureFlags} from './future/flags';\n\n/**\n * Creates an object your app will use to interact with Shopify.\n *\n * @param appConfig Configuration options for your Shopify app, such as the scopes your app needs.\n * @returns `ShopifyApp` An object constructed using your appConfig.  It has methods for interacting with Shopify.\n *\n * @example\n * <caption>The minimum viable configuration</caption>\n * ```ts\n * // /shopify.server.ts\n * import { shopifyApp } from \"@shopify/shopify-app-remix/server\";\n *\n * const shopify = shopifyApp({\n *   apiKey: process.env.SHOPIFY_API_KEY!,\n *   apiSecretKey: process.env.SHOPIFY_API_SECRET!,\n *   scopes: process.env.SCOPES?.split(\",\")!,\n *   appUrl: process.env.SHOPIFY_APP_URL!,\n * });\n * export default shopify;\n * ```\n */\nexport function shopifyApp<\n  Config extends AppConfigArg<Resources, Storage, Future>,\n  Resources extends ShopifyRestResources,\n  Storage extends SessionStorage,\n  Future extends FutureFlagOptions = Config['future'],\n>(appConfig: Readonly<Config>): ShopifyApp<Config> {\n  const api = deriveApi(appConfig);\n  const config = deriveConfig<Storage>(appConfig, api.config);\n  const logger = overrideLogger(api.logger);\n\n  if (appConfig.webhooks) {\n    api.webhooks.addHandlers(appConfig.webhooks);\n  }\n\n  const params: BasicParams = {api, config, logger};\n\n  let strategy;\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    strategy = new MerchantCustomAuth(params);\n  } else if (\n    config.future.unstable_newEmbeddedAuthStrategy &&\n    config.isEmbeddedApp\n  ) {\n    strategy = new TokenExchangeStrategy(params);\n  } else {\n    strategy = new AuthCodeFlowStrategy(params);\n  }\n\n  const authStrategy = authStrategyFactory<Config, Resources>({\n    ...params,\n    strategy,\n  });\n\n  const shopify:\n    | AdminApp<Config>\n    | AppStoreApp<Config>\n    | SingleMerchantApp<Config> = {\n    sessionStorage: config.sessionStorage,\n    addDocumentResponseHeaders: addDocumentResponseHeadersFactory(params),\n    registerWebhooks: registerWebhooksFactory(params),\n    authenticate: {\n      admin: authStrategy,\n      flow: authenticateFlowFactory<Config, Resources>(params),\n      public: authenticatePublicFactory<Config, Resources>(params),\n      fulfillmentService: authenticateFulfillmentServiceFactory<\n        Config,\n        Resources\n      >(params),\n      webhook: authenticateWebhookFactory<Config, Resources, string>(params),\n    },\n    unauthenticated: {\n      admin: unauthenticatedAdminContextFactory<Config, Resources>(params),\n      storefront: unauthenticatedStorefrontContextFactory(params),\n    },\n  };\n\n  if (\n    isAppStoreApp(shopify, appConfig) ||\n    isSingleMerchantApp(shopify, appConfig)\n  ) {\n    shopify.login = loginFactory(params);\n  }\n\n  logDisabledFutureFlags(config, logger);\n\n  return shopify as ShopifyApp<Config>;\n}\n\nfunction isAppStoreApp<Config extends AppConfigArg>(\n  _shopify: ShopifyAppBase<Config>,\n  config: Config,\n): _shopify is AppStoreApp<Config> {\n  return config.distribution === AppDistribution.AppStore;\n}\n\nfunction isSingleMerchantApp<Config extends AppConfigArg>(\n  _shopify: ShopifyAppBase<Config>,\n  config: Config,\n): _shopify is SingleMerchantApp<Config> {\n  return config.distribution === AppDistribution.SingleMerchant;\n}\n\n// This function is only exported so we can unit test it without having to mock the underlying module.\n// It's not available to consumers of the library because it is not exported in the index module, and never should be.\nexport function deriveApi(appConfig: AppConfigArg): BasicParams['api'] {\n  let appUrl: URL;\n  try {\n    appUrl = new URL(appConfig.appUrl);\n  } catch (error) {\n    const message =\n      appConfig.appUrl === ''\n        ? `Detected an empty appUrl configuration, please make sure to set the necessary environment variables.\\n` +\n          `If you're deploying your app, you can find more information at https://shopify.dev/docs/apps/launch/deployment/deploy-web-app/deploy-to-hosting-service#step-4-set-up-environment-variables`\n        : `Invalid appUrl configuration '${appConfig.appUrl}', please provide a valid URL.`;\n    throw new ShopifyError(message);\n  }\n\n  /* eslint-disable no-process-env */\n  if (appUrl.hostname === 'localhost' && !appUrl.port && process.env.PORT) {\n    appUrl.port = process.env.PORT;\n  }\n  /* eslint-enable no-process-env */\n  appConfig.appUrl = appUrl.origin;\n\n  let userAgentPrefix = `Shopify Remix Library v${SHOPIFY_REMIX_LIBRARY_VERSION}`;\n  if (appConfig.userAgentPrefix) {\n    userAgentPrefix = `${appConfig.userAgentPrefix} | ${userAgentPrefix}`;\n  }\n\n  return shopifyApi({\n    ...appConfig,\n    hostName: appUrl.host,\n    hostScheme: appUrl.protocol.replace(':', '') as 'http' | 'https',\n    userAgentPrefix,\n    isEmbeddedApp: appConfig.isEmbeddedApp ?? true,\n    apiVersion: appConfig.apiVersion ?? LATEST_API_VERSION,\n    isCustomStoreApp: appConfig.distribution === AppDistribution.ShopifyAdmin,\n    billing: appConfig.billing as ApiConfig['billing'],\n    future: {\n      lineItemBilling: true,\n      unstable_managedPricingSupport: true,\n    },\n    _logDisabledFutureFlags: false,\n  });\n}\n\nfunction deriveConfig<Storage extends SessionStorage>(\n  appConfig: AppConfigArg,\n  apiConfig: ApiConfig,\n): AppConfig<Storage> {\n  if (\n    !appConfig.sessionStorage &&\n    appConfig.distribution !== AppDistribution.ShopifyAdmin\n  ) {\n    throw new ShopifyError(\n      'Please provide a valid session storage. Refer to https://github.com/Shopify/shopify-app-js/blob/main/README.md#session-storage-options for options.',\n    );\n  }\n\n  const authPathPrefix = appConfig.authPathPrefix || '/auth';\n  appConfig.distribution = appConfig.distribution ?? AppDistribution.AppStore;\n\n  return {\n    ...appConfig,\n    ...apiConfig,\n    billing: appConfig.billing as ApiConfig['billing'],\n    scopes: apiConfig.scopes,\n    idempotentPromiseHandler: new IdempotentPromiseHandler(),\n    canUseLoginForm: appConfig.distribution !== AppDistribution.ShopifyAdmin,\n    useOnlineTokens: appConfig.useOnlineTokens ?? false,\n    hooks: appConfig.hooks ?? {},\n    sessionStorage: appConfig.sessionStorage as Storage,\n    future: appConfig.future ?? {},\n    auth: {\n      path: authPathPrefix,\n      callbackPath: `${authPathPrefix}/callback`,\n      patchSessionTokenPath: `${authPathPrefix}/session-token`,\n      exitIframePath: `${authPathPrefix}/exit-iframe`,\n      loginPath: `${authPathPrefix}/login`,\n    },\n    distribution: appConfig.distribution,\n  };\n}\n", "import '@shopify/shopify-api/adapters/web-api';\nimport {setAbstractRuntimeString} from '@shopify/shopify-api/runtime';\n\nsetAbstractRuntimeString(() => {\n  return `Remix`;\n});\n\nexport {\n  LATEST_API_VERSION,\n  RELEASE_CANDIDATE_API_VERSION,\n  LogSeverity,\n  DeliveryMethod,\n  BillingInterval,\n  BillingReplacementBehavior,\n  ApiVersion,\n  Session,\n} from '@shopify/shopify-api';\n\nexport type {JwtPayload} from '@shopify/shopify-api';\n\nexport type * from './types-contexts';\nexport type {ShopifyApp, LoginError} from './types';\nexport {LoginErrorType, AppDistribution} from './types';\nexport {boundary} from './boundary';\nexport {shopifyApp} from './shopify-app';\nexport * from './errors';\n", "import { LoaderFunctionArgs } from \"@remix-run/node\";\r\nimport { shopify } from \"~/shopify.server\";\r\n\r\nexport async function loader({ request }: LoaderFunctionArgs) {\r\n  // \u3053\u308C\u304C Response \u3092\u8FD4\u3059\uFF08\u30EA\u30C0\u30A4\u30EC\u30AF\u30C8\u542B\u3080\uFF09\r\n  return shopify.authenticate.admin(request);\r\n}\r\n\r\n", "import { json } from \"@remix-run/node\";\r\nimport { authenticate } from \"~/shopify.server\";\r\n\r\nexport const loader = async ({ request }: { request: Request }) => {\r\n  const { session } = await authenticate.admin(request);\r\n\r\n  return json({ shop: session.shop, accessToken: session.accessToken });\r\n};\r\n\r\n", "import React, { useEffect, useState } from \"react\";\r\nimport { createApp } from \"@shopify/app-bridge\";\r\nimport { authenticatedFetch } from \"../utils/authenticatedFetch.js\";\r\n\r\nexport default function Index() {\r\n  const [shop, setShop] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    // \u2705 App Bridge \u521D\u671F\u5316\r\n    const host =\r\n      window.__SHOPIFY_HOST__ ||\r\n      new URLSearchParams(window.location.search).get(\"host\") ||\r\n      \"\";\r\n    const apiKey = window.__SHOPIFY_API_KEY__ || \"\";\r\n\r\n    if (!host) {\r\n      console.error(\"\u274C host \u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\");\r\n      return;\r\n    }\r\n\r\n    const app = createApp({\r\n      apiKey,\r\n      host,\r\n      forceRedirect: true,\r\n    });\r\n\r\n    // \u2705 \u8A8D\u8A3C\u4ED8\u304D fetch\r\n    const fetchWithAuth = authenticatedFetch(app);\r\n\r\n    // API route \u547C\u3073\u51FA\u3057\r\n    fetchWithAuth(\"/api/test\")\r\n      .then((res) => res.json())\r\n      .then((data) => {\r\n        console.log(\"API response:\", data);\r\n        setShop(data.shop || null);\r\n      })\r\n      .catch((err) => console.error(\"API error:\", err));\r\n  }, []);\r\n\r\n  return (\r\n    <div style={{ padding: \"2rem\" }}>\r\n      <h1>Brand Logo List App</h1>\r\n      <p>\r\n        This app can be operated from the customization screen of the online\r\n        store. <br />\r\n        You can add it by selecting <strong>Add Section \u2192 Apps \u2192 Brand Logo\r\n        List App</strong>.\r\n      </p>\r\n\r\n      {/* API\u30C6\u30B9\u30C8\u306E\u7D50\u679C\u8868\u793A */}\r\n      {shop && (\r\n        <p style={{ marginTop: \"1rem\", color: \"green\" }}>\r\n          \u2705 Connected to shop: <strong>{shop}</strong>\r\n        </p>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\n", "import { getSessionToken } from \"@shopify/app-bridge-utils\";\nexport function authenticatedFetch(app) {\n    return async (uri, options = {}) => {\n        const token = await getSessionToken(app);\n        options.headers = {\n            ...options.headers,\n            Authorization: `Bearer ${token}`,\n            \"Content-Type\": \"application/json\",\n        };\n        return fetch(uri, options);\n    };\n}\n", "export default {'entry':{'module':'/build/entry.client-V2D2CCY2.js','imports':['/build/_shared/chunk-O4BRYNJ4.js','/build/_shared/chunk-DPWS7JE7.js','/build/_shared/chunk-U4FRFQSK.js','/build/_shared/chunk-3QAGCJ4N.js','/build/_shared/chunk-UWV35TSL.js','/build/_shared/chunk-XGOTYLZ5.js','/build/_shared/chunk-7M6SC7J5.js','/build/_shared/chunk-PNG5AS42.js']},'routes':{'root':{'id':'root','parentId':undefined,'path':'','index':undefined,'caseSensitive':undefined,'module':'/build/root-VGPSIOZN.js','imports':undefined,'hasAction':false,'hasLoader':true,'hasClientAction':false,'hasClientLoader':false,'hasErrorBoundary':false},'routes/_index':{'id':'routes/_index','parentId':'root','path':undefined,'index':true,'caseSensitive':undefined,'module':'/build/routes/_index-N3HE2RD7.js','imports':undefined,'hasAction':false,'hasLoader':false,'hasClientAction':false,'hasClientLoader':false,'hasErrorBoundary':false},'routes/api.auth':{'id':'routes/api.auth','parentId':'root','path':'api/auth','index':undefined,'caseSensitive':undefined,'module':'/build/routes/api.auth-ZQPR3C3J.js','imports':undefined,'hasAction':false,'hasLoader':true,'hasClientAction':false,'hasClientLoader':false,'hasErrorBoundary':false},'routes/api.auth.callback':{'id':'routes/api.auth.callback','parentId':'routes/api.auth','path':'callback','index':undefined,'caseSensitive':undefined,'module':'/build/routes/api.auth.callback-CIM7Y5RR.js','imports':undefined,'hasAction':false,'hasLoader':true,'hasClientAction':false,'hasClientLoader':false,'hasErrorBoundary':false},'routes/api.test':{'id':'routes/api.test','parentId':'root','path':'api/test','index':undefined,'caseSensitive':undefined,'module':'/build/routes/api.test-DCBEUBSL.js','imports':undefined,'hasAction':false,'hasLoader':true,'hasClientAction':false,'hasClientLoader':false,'hasErrorBoundary':false}},'version':'5196c24e','hmr':{'runtime':'/build/_shared\\\\chunk-3QAGCJ4N.js','timestamp':1755621008793},'url':'/build/manifest-5196C24E.js'};", "\nimport * as entryServer from \"C:\\\\Users\\\\takeshita tomoya\\\\Desktop\\\\Shopify-app-build\\\\brand-logo\\\\node_modules\\\\@remix-run\\\\dev\\\\dist\\\\config\\\\defaults\\\\entry.server.node.tsx\";\nimport * as route0 from \"./root.tsx\";\nimport * as route1 from \"./routes/api.auth.callback.tsx\";\nimport * as route2 from \"./routes/api.auth.tsx\";\nimport * as route3 from \"./routes/api.test.tsx\";\nimport * as route4 from \"./routes/_index.tsx\";\n  export const mode = \"development\";\n  export { default as assets } from \"@remix-run/dev/assets-manifest\";\n  export const assetsBuildDirectory = \"public\\\\build\";\n  export const future = {\"v3_fetcherPersist\":false,\"v3_relativeSplatPath\":false,\"v3_throwAbortReason\":false,\"v3_routeConfig\":false,\"v3_singleFetch\":false,\"v3_lazyRouteDiscovery\":false,\"unstable_optimizeDeps\":false};\n  export const publicPath = \"/build/\";\n  export const entry = { module: entryServer };\n  export const routes = {\n    \"root\": {\n      id: \"root\",\n      parentId: undefined,\n      path: \"\",\n      index: undefined,\n      caseSensitive: undefined,\n      module: route0\n    },\n  \"routes/api.auth.callback\": {\n      id: \"routes/api.auth.callback\",\n      parentId: \"routes/api.auth\",\n      path: \"callback\",\n      index: undefined,\n      caseSensitive: undefined,\n      module: route1\n    },\n  \"routes/api.auth\": {\n      id: \"routes/api.auth\",\n      parentId: \"root\",\n      path: \"api/auth\",\n      index: undefined,\n      caseSensitive: undefined,\n      module: route2\n    },\n  \"routes/api.test\": {\n      id: \"routes/api.test\",\n      parentId: \"root\",\n      path: \"api/test\",\n      index: undefined,\n      caseSensitive: undefined,\n      module: route3\n    },\n  \"routes/_index\": {\n      id: \"routes/_index\",\n      parentId: \"root\",\n      path: undefined,\n      index: true,\n      caseSensitive: undefined,\n      module: route4\n    }\n  };"],
  "mappings": "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",
  "names": ["import_react", "import_jsx_dev_runtime", "loader", "AppDistribution", "LoginErrorType", "isEmbeddedRequest", "isEmbeddedRequest", "params", "SESSION_TOKEN_PARAM", "remixRedirect", "remixRedirect", "admin", "shop", "sessionId", "warningFunction", "semver", "searchParams", "shopify", "loader", "loader", "loader", "loader", "import_node", "loader", "import_react", "import_jsx_dev_runtime"]
}
